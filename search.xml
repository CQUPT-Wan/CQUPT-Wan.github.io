<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer（51-66）]]></title>
    <url>%2F20190527-sword-to-offer-6.html</url>
    <content type="text"><![CDATA[51、 构建乘积数组给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。解答：方法：B[i]**的值可以看作下图的矩阵中每行的乘积。**下三角用连乘可以很容求得，上三角，从下向上也是连乘。因此我们的思路就很清晰了，先算下三角中的连乘，即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。# -*- coding:utf-8 -*- class Solution: def multiply(self, A): # write code here B = [1] * len(A) B[0] = 1 for i in range(1,len(A)): B[i] = B[i-1] * A[i-1] tmp = 1 for j in reversed(range(0,len(A)-1)): tmp *= A[j+1] B[j] = B[j] * tmp return B 52、正则表达式匹配请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配解答：方法：考虑情况1、s和pattern同时为空时，返回True2、s不为空，pattern为空时，返回False3、s为空，pattern不为空时，需要判断pattern[1]是否为’’，注意这里还要判断len(pattern) > 1，如果满足，则pattern后移两位继续判断，因为可能有’’，’abc’的情况；否则直接返回False；4、如果s不为空，pattern[1] == ‘*’时，这时分为两种情况判断：1）如果s[0] != pattern[0]时，pattern后移两位继续判断2）s[0] == pattern[0] or pattern[0] == ‘.’时分三种情况：A）pattern后移2个，s不变；相当于把pattern前两位当成空，匹配后面的B）pattern后移2个，s后移1个；相当于pattern前两位与s[0]匹配，A和B可以结合在一起C）pattern不变，s后移1个；相当于pattern前两位，与s中的多位进行匹配，因为*可以匹配多位5）pattern[1] != ‘*’时，如果s[0] == pattern[0] or pattern[0] == ‘.’，则s后移1位，pattern后移一位继续判断，否则返回False# -*- coding:utf-8 -*- class Solution: # s, pattern都是字符串 def match(self, s, pattern): # write code here if len(s) == 0 and len(pattern) == 0: return True if len(s) != 0 and len(pattern) == 0: return False if len(s) == 0 and len(pattern) != 0: if len(pattern) > 1 and pattern[1] == '*': return self.match(s,pattern[2:]) return False else: if len(pattern) > 1 and pattern[1] == '*': if s[0] == pattern[0] or pattern[0] == '.': return self.match(s[1:],pattern) or self.match(s,pattern[2:]) else: return self.match(s,pattern[2:]) else: if s[0] == pattern[0] or pattern[0] == '.': return self.match(s[1:],pattern[1:]) else: return False 53、 表示数值的字符串请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。解答：方法：1、e后面一定要接数字2、不能同时存在两个e3、第二次出现+-符号，则必须紧接在e之后4、第一次出现+-符号，且不是在字符串开头，则也必须紧接在e之后5、e后面不能接小数点，小数点不能出现两次6、不能出现不合法字符，只能在0-97、+、-、.单独出现时返回False# -*- coding:utf-8 -*- class Solution: # s字符串 def isNumeric(self, s): # write code here symbol = False point = False hasE = False for i in range(len(s)): if s[i] == 'e' or s[i] == 'E': if hasE or i == len(s) - 1: return False hasE = True continue if s[i] == '.': if hasE or point: return False if i == 0 and len(s) == 1: return False point = True continue if s[i] == '+' or s[i] == '-': if symbol and s[i-1] != 'e' and s[i-1] != 'E': return False elif not symbol and i != 0 and s[i-1] != 'e' and s[i-1] != 'E': return False elif i == 0 and len(s) == 1: return False symbol = True continue if s[i] > '9' or s[i] &lt; '0': return False return True 54、字符流中第一个不重复的字符请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。输出：如果当前字符流没有存在出现一次的字符，返回#字符。解答：方法：字典# -*- coding:utf-8 -*- class Solution: # 返回对应char def __init__(self): self.s = '' self.s_dict = {} def FirstAppearingOnce(self): # write code here for i in self.s: if self.s_dict[i] == 1: return i return '#' def Insert(self, char): # write code here self.s += char if char not in self.s_dict: self.s_dict[char] = 0 self.s_dict[char] += 1 55、链表中环的入口结点给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。解答：1、第一步，找环中相汇点。分别用p1，p2指向链表头部，p1每次走一步，p2每次走二步，直到p1==p2找到在环中的相汇点。2、第二步，找环的入口。接上步，当p1=p2时，p2所经过节点数为2x,p1所经过节点数为x,设环中有n个节点,p2比p1多走m圈有2x= mn+x; mn=x；可以看出p1实际走了一个环的步数，再让p2指向链表头部，p1位置不变，p1,p2每次走一步直到p1=p2; 此时p1指向环的入口。# -*- coding:utf-8 -*- # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def EntryNodeOfLoop(self, pHead): # write code here if not pHead or not pHead.next: return None p1 = pHead p2 = pHead while pHead and pHead.next: p1 = p1.next p2 = p2.next.next if p1 == p2: p2 = pHead while p1 != p2: p2 = p2.next p1 = p1.next return p1 return None 56、 删除链表中重复的结点在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5解答：方法：1->2->3->4->2，不会删除2，只会删除连续重复的结点1、设置一个空结点first，first.next = pHead，目的是解决头指针重复的情况2、设置last = first，作为删除结点的前一个结点，目的是能够保证链表不断。# -*- coding:utf-8 -*- # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def deleteDuplication(self, pHead): # write code here first = ListNode(None) first.next = pHead p = pHead last = first if not pHead: return None while p and p.next: if p.val == p.next.val: p_val = p.val while p and p.val == p_val: p = p.next last.next = p else: last = p p = p.next return first.next 57、 二叉树的下一个结点给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。解答：方法：1、结点为空，返回空2、结点的右子树存在，找到其右子树最左边的结点3、结点位于其父结点的左子树，则下个结点就是其父结点4、结点位于其父结点的右子树，向上寻找父结点，直到找到一个结点是其父结点的左结点，这个父结点就是下个结点# -*- coding:utf-8 -*- # class TreeLinkNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None # self.next = None class Solution: def GetNext(self, pNode): # write code here if not pNode: return None if pNode.right: node = pNode.right while node.left: node = node.left return node while pNode.next: pRoot = pNode.next if pRoot.left == pNode: return pRoot pNode = pNode.next return None 58、对称的二叉树请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。解答：程序方法1：递归方法2：非递归利用堆栈，成对进栈和出栈需要注意，这里是continue而不是return Ture# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def isSymmetrical(self, pRoot): return self.isSymmetrical_part(pRoot,pRoot) def isSymmetrical_part(self,pRoot1,pRoot2): if not pRoot1 and not pRoot2: return True if not pRoot1 or not pRoot2: return False if pRoot1.val != pRoot2.val: return False return self.isSymmetrical_part(pRoot1.left,pRoot2.right) and self.isSymmetrical_part(pRoot1.right,pRoot2.left) def isSymmetrical(self, pRoot): # write code here res = [] if not pRoot: return True pRoot_left = pRoot.left pRoot_right = pRoot.right res.append(pRoot_left) res.append(pRoot_right) while res: p_right = res.pop() p_left = res.pop() if not p_left and not p_right: continue if not p_left or not p_right: return False if p_left.val != p_right.val: return False res.append(p_left.left) res.append(p_right.right) res.append(p_left.right) res.append(p_right.left) return True 59、按之字形顺序打印二叉树请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。解答：方法：层次遍历，奇数层正序输出，偶数层倒序输出# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def Print(self, pRoot): # write code here if not pRoot: return [] stack = [] node = pRoot sum_count = 1 count = 0 depth = 1 stack.append(node) res = [] result = [] while stack: node = stack.pop(0) count += 1 res.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) if count == sum_count: sum_count = len(stack) if depth % 2 != 0: result.append(res) else: res.reverse() result.append(res) count = 0 depth += 1 res = [] return result 60、 把二叉树打印成多行从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。解答：方法：层次遍历# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if not pRoot: return [] stack = [] node = pRoot sum_count = 1 count = 0 stack.append(node) res = [] result = [] while stack: node = stack.pop(0) count += 1 res.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) if count == sum_count: sum_count = len(stack) result.append(res) count = 0 res = [] return result 61、序列化二叉树请实现两个函数，分别用来序列化和反序列化二叉树解答：方法：1、对于序列化：使用前序遍历，递归的将二叉树的值转化为字符，并且在每次二叉树的结点不为空时，在转化val所得的字符之后添加一个’ ， ‘作为分割。对于空节点则以 ‘#’ 代替。2、对于反序列化：按照前序顺序，递归的使用字符串中的字符创建一个二叉树(特别注意：在递归时，递归函数的参数一定要是char ** ，这样才能保证每次递归后指向字符串的指针会随着递归的进行而移动！！！)# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def __init__(self): self.flag = -1 def Serialize(self, root): if not root: return '#' return str(root.val) + ',' + self.Serialize(root.left) + ',' + self.Serialize(root.right) # write code here def Deserialize(self, s): self.flag += 1 s_list = s.split(',') if self.flag >= len(s_list): return None root = None if s_list[self.flag] != '#': root = TreeNode(int(s_list[self.flag])) root.left = self.Deserialize(s) root.right = self.Deserialize(s) return root 62、二叉搜索树的第k个结点给定一棵二叉搜索树，请找出其中的第k小的结点。例如，（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。解答：方法：中序遍历# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: # 返回对应节点TreeNode def __init__(self): self.res = [] def KthNode(self, pRoot, k): self.Inorder(pRoot) if k == 0 or k > len(self.res) or not pRoot: return None return self.res[k - 1] def Inorder(self, root): if not root: return None self.Inorder(root.left) self.res.append(root) self.Inorder(root.right) def KthNode(self, pRoot, k): # write code here if not pRoot or k == 0: return None node = pRoot stack = [] res = [] while stack or node: while node: stack.append(node) node = node.left node = stack.pop() res.append(node) node = node.right if k > len(res): return None return res[k-1] 63、 数据流中的中位数如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。解答：方法：# -*- coding:utf-8 -*- class Solution: def __init__(self): self.stack = [] def Insert(self, num): # write code here self.stack.append(num) self.stack.sort() def GetMedian(self,stack): # write code here if len(self.stack) & 1 == 1: return self.stack[len(self.stack)>>1] else: return float(self.stack[len(self.stack)>>1] + self.stack[(len(self.stack)>>1)-1]) / 2 64、滑动窗口的最大值给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。解答：方法：1、size = 0，返回[]2、滑动窗口内存储最大值在num中的index，如果新进队列的值num[index]大于max_stack[0]，则清空max_stack，3、如果小于max_stack[0]，则从后往前删除比这个数小的数，并将这个数添加到list4、如果max_stack[0]的值不大于index-size，说明这个值已经划出窗口，需要pop(0)# -*- coding:utf-8 -*- class Solution: def maxInWindows(self, num, size): # write code here if size == 0: return [] max_stack = [] res = [] index = 0 while index &lt; len(num): if not max_stack or num[max_stack[0]] &lt; num[index]: del max_stack[:] max_stack.append(index) elif max_stack[0] &lt;= index - size: max_stack.pop(0) max_stack.append(index) else: for i in reversed(range(1, len(max_stack))): if num[max_stack[i]] &lt; num[index]: max_stack.pop(i) max_stack.append(index) if index >= size - 1: res.append(num[max_stack[0]]) index += 1 return res 65、 矩阵中的路径请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。解答：方法：1、根据给定数组，初始化一个标志位数组，初始化为false，表示未走过，true表示已经走过，不能走第二次2、根据行数和列数，遍历数组，先找到一个与str字符串的第一个元素相匹配的矩阵元素，进入judge3、根据i和j先确定一维数组的位置，因为给定的matrix是一个一维数组 /4、确定递归终止条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的，这三类情况，都直接false，说明这条路不通5、若k，就是待判定的字符串str的索引已经判断到了最后一位，此时说明是匹配成功的6、下面就是本题的精髓，递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。7、走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。class Solution: def hasPath(self, matrix, rows, cols, path): # write code here if not path or not matrix or (rows == 0 and cols == 0): return False isvisited = [0] * len(matrix) path_lengh = 0 for i in range(rows): for j in range(cols): if self.hasPath_part(matrix,rows,cols,i,j,path,path_lengh,isvisited): return True return False def hasPath_part(self,matrix,rows,cols,i,j,path,path_length,isvisited): index = i * cols + j if i &lt; 0 or i >= rows or j &lt; 0 or j >= cols or matrix[index] != path[path_length] or isvisited[index] == 1: return False if path_length == len(path) - 1: return True isvisited[index] = 1 if self.hasPath_part(matrix,rows,cols,i+1,j,path,path_length+1,isvisited) \ or self.hasPath_part(matrix, rows, cols, i - 1, j, path, path_length + 1, isvisited) \ or self.hasPath_part(matrix,rows,cols,i,j+1,path,path_length+1,isvisited) \ or self.hasPath_part(matrix,rows,cols,i,j-1,path,path_length+1,isvisited): return True isvisited[index] = 0 return False 66、机器人的运动范围地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？解答：方法# -*- coding:utf-8 -*- class Solution: def movingCount(self, threshold, rows, cols): # write code here isvisited = [0] * (rows * cols) count = self.movingCount_part(threshold, rows, cols,0,0,isvisited) return count def movingCount_part(self, threshold, rows, cols,i,j,isvisited): count = 0 if self.check(threshold, rows, cols,i,j,isvisited): isvisited[i*cols+j] = 1 count = 1 + self.movingCount_part(threshold, rows, cols,i-1,j,isvisited) \ + self.movingCount_part(threshold, rows, cols,i+1,j,isvisited) \ + self.movingCount_part(threshold, rows, cols,i,j-1,isvisited) \ + self.movingCount_part(threshold, rows, cols,i,j+1,isvisited) return count def check(self,threshold, rows, cols,i,j,isvisited): if i &lt; 0 or i >= rows or j &lt; 0 or j >= cols \ or isvisited[i*cols + j] == 1 \ or self.get_num(i) + self.get_num(j) > threshold: return False return True def get_num(self,num): sum = 0 while num > 0: sum += num % 10 num = int(num / 10) return sum document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>编程实践</category>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer（41-50）]]></title>
    <url>%2F20190527-sword-to-offer-5.html</url>
    <content type="text"><![CDATA[41、和为S的连续正数序列小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!解答：方法1：动态规划方法2：双指针技术两个起点相当于动态窗口的两边，根据窗口内的值来确定窗口的位置。当窗口内的值小于S时，右边窗口向后移动一位；大于S时，左边窗口向后移动一位# -*- coding:utf-8 -*- import math class Solution: def FindContinuousSequence(self, tsum): # write code here n = int(math.sqrt(tsum)*2) res_list = [] for i in range(2,n+1): if (tsum-i*(i-1)/2) % i == 0: a = (tsum-i*(i-1)/2) / i if a > 0: res_list.append(int(a)) res_list = sorted(res_list) result = [] for i in res_list: tmp_sum = 0 tmp_list = [] while tmp_sum != tsum: tmp_sum += i tmp_list.append(i) i += 1 result.append(tmp_list) return result def FindContinuousSequence(self, tsum): begin = 1 end = 2 res = [] while end > begin: if (begin+end)*(end-begin+1)/2 == tsum: tmp_list = [] for i in range(begin,end+1): tmp_list.append(i) res.append(tmp_list) begin += 1 if (begin+end)*(end-begin+1)/2 &lt; tsum: end += 1 if (begin+end)*(end-begin+1)/2 > tsum: begin += 1 return res 42、和为S的两个数字输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。解答：方法：左右夹逼设置两个窗口index，分别为0和len(array)-1，计算两个窗口值的和是否为S，若大于S，右边窗口向前移动一位，小于S左边窗口向后移动一位；因为两个数的乘积相隔越远越小，因此第一个找到的窗口值就是结果# -*- coding:utf-8 -*- class Solution: def FindNumbersWithSum(self, array, tsum): # write code here begin = 0 end = len(array) - 1 while begin &lt; end: if array[begin] + array[end] == tsum: return array[begin],array[end] if array[begin] + array[end] > tsum: end -= 1 if array[begin] + array[end] &lt; tsum: begin += 1 return [] 43、左旋转字符串汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！解答：方法：n为移动的位数，m为字符串s的长度。s为0时返回‘’；移动位数k=n%m，然后s = s[:k] + s[k:]；如果不能申请额外的空间，则将s[:k]和s[k:]分别反转，然后将整个s反转即所求# -*- coding:utf-8 -*- class Solution: def LeftRotateString(self, s, n): # write code here m = len(s) if m == 0: return '' if n % m == 0: return s k = n % m s = s[k:] + s[:k] return s 44、翻转单词顺序列牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？解答：方法1：将字符串转换成list，翻转list即可方法2：首先将字符串翻转，然后将每个单词翻转# -*- coding:utf-8 -*- class Solution: def ReverseSentence(self, s): # write code here s_list = s.split(' ') s_list = reversed(s_list) return ' '.join(s_list) def ReverseSentence(self, s): s = list(s) begin = 0 end = len(s) - 1 self.ReversePart(s,begin,end) begin_part = 0 end_part = 0 while begin_part &lt; len(s) and end_part &lt; len(s): if s[begin_part] == ' ': begin_part += 1 end_part += 1 elif s[end_part] == ' ': self.ReversePart(s, begin_part, end_part - 1) begin_part = end_part + 1 end_part += 1 elif end_part + 1 == len(s): self.ReversePart(s, begin_part, end_part) begin_part = end_part + 1 end_part += 1 else: end_part += 1 return ''.join(s) def ReversePart(self,s,begin,end): while begin &lt; end: s[begin],s[end] = s[end],s[begin] begin += 1 end -= 1 45、 扑克牌顺子LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。解答：方法：max 记录 最大值min 记录 最小值min ,max 都不记0满足条件1、max - min &lt; 52、没有重复的数字(牌)3、数组长度为5# -*- coding:utf-8 -*- class Solution: def IsContinuous(self, numbers): # write code here if len(numbers) == 0: return False num = [0] * 14 num[0] = -5 min_ = 14 max_ = -1 for i in range(len(numbers)): num[numbers[i]] += 1 if num[numbers[i]] > 1: return False if numbers[i] == 0: continue if numbers[i] > max_: max_ = numbers[i] if numbers[i] &lt; min_: min_ = numbers[i] if max_ - min_ &lt; 5: return True return False 46、孩子们的游戏(圆圈中最后剩下的数)每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)解答：方法：约瑟夫问题把n个人的编号改为0~n-1，然后对删除的过程进行分析。第一个删除的数字是(m-1)%n，几位k，则剩余的编号为(0,1,…,k-1,k+1,…,n-1)，下次开始删除时，顺序为(k+1,…,n-1,0,1,…k-1)。用f(n,m)表示从(0~n-1)开始删除后的最终结果。用q(n-1,m)表示从(k+1,…,n-1,0,1,…k-1)开始删除后的最终结果。则f(n,m)=q(n-1,m)。下面把(k+1,…,n-1,0,1,…k-1)转换为(0~n-2)的形式，即k+1对应0k+2对于1…k-1对应n-2转化函数设为p(x)=(x-k-1)%n, p(x)的你函数为p^(x)=(x+k+1)%n。则f(n,m)=q(n-1,m)=p^(f(n-1,m))=(f(n-1,m)+k+1)%n，又因为k=(m-1)%n。f(n,m)=(f(n-1,m)+m)%n;最终的递推关系式为==f(1,m) = 0; (n=1)====f(n,m)=(f(n-1,m)+m)%n; （n>1）==# -*- coding:utf-8 -*- class Solution: def LastRemaining_Solution(self, n, m): # write code here if n == 0 or m == 0: return -1 if n == 1: return 0 res = 0 for i in range(2,n+1): res = (res + m) % i return res 47、求1+2+3+…+n求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。解答：方法：1.需利用逻辑与的短路特性实现递归终止。2.当n==0时，(n>0)&&((sum+=Sum_Solution(n-1))>0)只执行前面的判断，为false，然后直接返回0；3.当n>0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。# -*- coding:utf-8 -*- class Solution: def Sum_Solution(self, n): # write code here return n and (n +self.Sum_Solution(n-1)) 48、不用加减乘除做加法写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。解答：方法：使用==位运算==两个数相加可以看成两个数的每个位先相加，但不进位，然后在加上进位的数值如12+8可以看成二进制中可以表示为1000+1100 先每个位置相加不进位，异或结果：0100，出现进位，将与运算结果左移一位，(1000 & 1100) &lt;&lt; 1 = 1 0000最后将上面两步的结果相加，相加的时候依然要考虑进位的情况，直到不产生进位注意python没有无符号右移操作，所以需要越界检查按位与运算：相同位的两个数字都为1，则为1；若有一个不为1，则为0。按位异或运算：相同位不同则为1，相同则为0。# -*- coding:utf-8 -*- class Solution: def Add(self, num1, num2): # write code here while num2: result = (num1 ^ num2) & 0xffffffff carry = ((num1 & num2) &lt;&lt; 1) & 0xffffffff num1 = result num2 = carry if num1 &lt;= 0x7fffffff: result = num1 else: result = ~(num1^0xffffffff) return result 1、越界检查& 0xFFFFFFFF 操作，其中 & 是按位与， 0xFFFFFFFF代表16进制下的边界 （按二进制表示的话，对应4*8=32位）。由于python长整数类型可以表示无限位，所以需要人为设置边界，避免死循环。设置成32位应该是考虑到其他语言的特点，测试样例中不会出现超过32位整型的数，实际上，把边界调大的话，不会影响最终结果2、~(num1^0xffffffff)负数取反操作3、不使用新变量，交换两个变量的值49、 把字符串转换成整数将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。解答：方法：1、设置一个Invalid参数，因为字符串输出0和无效输入需要区分2、只计算整数，则每个字符s[i]，if s[i] &lt; '0' or s[i] > '9'则直接返回0，Invalid = True3、输入的字符串为空，同样输出0，Invalid = True4、正整数最大为 0x7FFFFFFF，负整数最小为0x80000000，注意负整数这里是res >0x80000000时输入无效# -*- coding:utf-8 -*- class Solution: def StrToInt(self, s): # write code here Invalid = False if not s: Invalid = True return 0 minus = 1 begin = 0 if s[0] == '+': begin = 1 if s[0] == '-': begin = 1 minus = -1 res = 0 for i in range(begin,len(s)): if s[i] &lt; '0' or s[i] > '9': Invalid = True return 0 res = res * 10 + minus * (int(s[i]) & 0xF) if ((minus == 1) and res > 0x7FFFFFFF) or ((minus == -1) and res > 0x80000000): Invalid = True return 0 return res 50、数组中重复的数字在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。解答：方法1：利用辅助空间dict，时间复杂度O(n)，空间复杂度O(n)方法2：将每一个数字放在对应的位置，即numbers[i] = i1、如果numbers[i] != i时，index = numbers[i]，交换number[i]和numbers[index]，注意这里不能直接使用swap或python交换公式，需要一步步进行2、当遇到numbers[i] == numbers[index]时，就终止循环，找到了这个重复的值为numbers[i]，3、因为每个数字最多交换两次就可以找到对应的位置，总时间复杂度为O(n)，空间复杂度为O(1)方法3：当一个数字被访问过后，可以设置对应位上的数 + n，之后再遇到相同的数时，会发现对应位上的数已经大于等于n了，那么直接返回这个数即可。注意：这种+len(numbers)的方式可能会溢出，时间复杂度O(n)，空间复杂度O(1)# -*- coding:utf-8 -*- class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): numbers_dict = {} if not numbers: return False for i in numbers: if i &lt; 0 or i >= len(numbers): return False if i not in numbers_dict: numbers_dict[i] = 0 numbers_dict[i] += 1 if numbers_dict[i] == 2: duplication[0] = i return True return False def duplicate(self, numbers, duplication): if not numbers: return False for i in range(len(numbers)): if numbers[i] &lt; 0 or numbers[i] >= len(numbers): return False while numbers[i] != i: if numbers[i] == numbers[numbers[i]]: duplication[0] = numbers[i] return True tmp = numbers[i] numbers[i] = numbers[tmp] numbers[tmp] = tmp return False def duplicate(self, numbers, duplication): if not numbers: return False for i in range(len(numbers)): if numbers[i] &lt; 0: return False index = numbers[i] if index >= len(numbers): index -= len(numbers) if numbers[index] >= len(numbers): duplication[0] = index return True numbers[index] += len(numbers) return False document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>编程实践</category>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer（31-40）]]></title>
    <url>%2F20190524-sword-to-offer-4.html</url>
    <content type="text"><![CDATA[31、 整数中1出现的次数（从1到n整数中1出现的次数）求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。解答：方法：设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析1、根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i2、当i表示百位，且百位对应的数>=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)*100个点的百位为13、当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10*100）+(b+1)，这些点百位对应为14、当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）5、综合以上三种情况，当百位对应0或>=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+16、之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位>=2，补8会产生进位位，效果等同于(a/10+1)# -*- coding:utf-8 -*- class Solution: def NumberOf1Between1AndN_Solution(self, n): # write code here i = 1 count = 0 while i &lt;= n: a = n / i b = n % i count = count + (a+8)/10*i + (a%10==1)*(b+1) i *= 10 return count 32、把数组排成最小的数输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。解答：方法：比较字符串s1和s2大小时，即比较s1+s2和s2+s1的大小，小的放在前面，比较某一位的字符时，需要将这个位置和其后面所有位置的字符串进行比较。时间复杂度为O(n^2)，注意两点：1、数组为空时要返回‘’；2、数组中全为0时，返回的是0，而不是00000.# -*- coding:utf-8 -*- class Solution: def PrintMinNumber(self, numbers): # write code here if numbers == []: return '' for i in range(len(numbers)): for j in range(i+1,len(numbers)): tmp0 = int(str(numbers[i]) + str(numbers[j])) tmp1 = int(str(numbers[j]) + str(numbers[i])) if tmp0 > tmp1: numbers[i],numbers[j] = numbers[j],numbers[i] res = '' for i in numbers: res += str(i) if int(res) == 0: return 0 else: return res 33、丑数把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。解答：方法1：暴力求解，任何丑数p，2p，3p，5p结果仍是偶数，1是最小的丑数，从1开始，将12,13,15比较，得到的最小丑数2，将得到的丑数2也同样2，3，*5，比较最小的数# -*- coding:utf-8 -*- class Solution: def GetUglyNumber_Solution(self, index): # write code here if index &lt; 7: return index res = [0] * index res[0] = 1 tmp2 = 0 tmp3 = 0 tmp5 = 0 for i in range(1,index): res[i] = min(res[tmp2]*2,res[tmp3]*3,res[tmp5]*5) if res[i] == res[tmp2]*2: tmp2 += 1 if res[i] == res[tmp3]*3: tmp3 += 1 if res[i] == res[tmp5]*5: tmp5 += 1 return res[-1] 34、第一个只出现一次的字符在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.解答：# -*- coding:utf-8 -*- class Solution: def FirstNotRepeatingChar(self, s): # write code here res_dict = {} for i in range(len(s)): if s[i] not in res_dict: res_dict[s[i]] = 0 res_dict[s[i]] += 1 for i in range(len(s)): if res_dict[s[i]] == 1: return i return -1 35、数组中的逆序对在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007解答：方法：归并排序，在合并时，当前面的数组值array[i]大于后面数组值array[j]时，则前面数组array[i]~array[mid]都是大于array[j]的，count += mid+1 - i# -*- coding:utf-8 -*- class Solution: def __init__(self): self.count = 0 def InversePairs(self, data): if len(data) == 0: return 0 # write code here self.MergeSort(data,0,len(data)-1) return self.count%1000000007 def MergeSort(self,array,low,high): if low &lt; high: mid = (low + high) >> 1 self.MergeSort(array,low,mid) self.MergeSort(array,mid+1,high) self.count += self.MergeArray(array,low,mid,high) def MergeArray(self,array,low,mid,high): i = low j = mid + 1 tmp = [] count = 0 while i &lt;= mid and j &lt;= high: if array[i] &lt; array[j]: tmp.append(array[i]) i += 1 else: tmp.append(array[j]) j += 1 count += mid - i + 1 while i &lt;= mid: tmp.append(array[i]) i += 1 while j &lt;= high: tmp.append(array[j]) j += 1 for k in range(len(tmp)): array[low + k] = tmp[k] return count 36、两个链表的第一个公共结点输入两个链表，找出它们的第一个公共结点。解答：方法1：长度相同有公共结点，第一次就遍历到；没有公共结点，走到尾部NULL相遇，返回NULL长度不同有公共结点，第一遍差值就出来了，第二遍一起到公共结点；没有公共，一起到结尾NULL。方法2：遍历两个链表，如果链表长度相同，找到第一个相同的结点；不相同时，先将长的链表移动到和短的链表相同长度的位置，然后找到第一个相同的结点# -*- coding:utf-8 -*- # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def FindFirstCommonNode(self, pHead1, pHead2): # write code here p1 = pHead1 p2 = pHead2 while p1 != p2: if not p1: p1 = pHead2 else: p1 = p1.next if not p2: p2 = pHead1 else: p2 = p2.next return p1 def FindFirstCommonNode(self, pHead1, pHead2): # write code here sum1 = self.get_length(pHead1) sum2 = self.get_length(pHead2) if sum1 > sum2: pHead1 = self.get_equal(pHead1,sum1-sum2) else: pHead2 = self.get_equal(pHead2,sum2-sum1) while pHead1 != pHead2: pHead1 = pHead1.next pHead2 = pHead2.next return pHead1 def get_equal(self,pHead,s): while s > 0: pHead = pHead.next s -= 1 return pHead def get_length(self,pHead): summ = 0 while pHead: pHead = pHead.next summ += 1 return summ 37、数字在排序数组中出现的次数统计一个数字在排序数组中出现的次数解答：方法1：排序数组是升序排列，且数组中的数都是整数，则可以使用tmp0 = k – 0.5 和tmp1 = k + 0.5两个数，这两个数在数组中都没有，但可以找到第一个大于tmp0和tmp1的数的index，相减就是最后k出现的次数方法2：如果数组中的数不是整数，则利用二分法找到k值的第一次出现的index和最后一次出现的index；注意考虑没有k值的情况。# -*- coding:utf-8 -*- class Solution: def GetNumberOfK(self, data, k): tmp0 = k - 0.5 tmp1 = k + 0.5 count = self.get_index(data,tmp1) - self.get_index(data,tmp0) return count def get_index(self,data,k): begin = 0 end = len(data) - 1 while begin &lt;= end: mid = (begin + end) >> 1 if data[mid] &lt; k: begin = mid + 1 elif data[mid] > k : end = mid - 1 return begin class Solution: def GetNumberOfK(self, data, k): tmp0 = self.get_first(data,k,0,len(data)-1) tmp1 = self.get_last(data, k, 0, len(data) - 1) if tmp0 != -1 and tmp1 != -1: return tmp1 - tmp0 + 1 return 0 def get_first(self,data,k,begin,end): if begin > end: return -1 mid = (begin + end) >> 1 if data[mid] > k: return self.get_first(data,k,begin,mid-1) elif data[mid] &lt; k: return self.get_first(data,k,mid+1,end) elif mid - 1 >= begin and data[mid-1] == k: return self.get_first(data,k,begin,mid-1) else: return mid def get_last(self,data,k,begin,end): while begin &lt;= end: mid = (begin + end) >> 1 if data[mid] > k: end = mid - 1 elif data[mid] &lt; k: begin = mid + 1 elif mid + 1 &lt;= end and data[mid+1] == k: begin = mid + 1 else: return mid return -1 38、 二叉树的深度输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。解答：方法1：递归，递归实际也是深度优先的思想（DFS）,时间复杂度为O(lgN),但是空间复杂度最坏为O(N),当二叉树退化为链表的时候。方法2：非递归，广度优先遍历BFS，时间复杂度O(N)；利用两个辅助值sum_count和count；sum_count记录每层的结点个数，当count == sum_count时说明一层的结点都已经遍历完毕，depth+1# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def TreeDepth(self, pRoot): if not pRoot: return 0 left = int(self.TreeDepth(pRoot.left)) right = int(self.TreeDepth(pRoot.right)) return max(left,right)+1 def TreeDepth(self, pRoot): # write code here if not pRoot: return 0 stack = [] stack.append(pRoot) sum_count = 1 count = 0 depth = 0 while stack: node = stack.pop(0) count += 1 if node.left: stack.append(node.left) if node.right: stack.append(node.right) if count == sum_count: count = 0 sum_count = len(stack) depth += 1 return depth 39、平衡二叉树输入一棵二叉树，判断该二叉树是否是平衡二叉树。解答：方法1：递归法有了求二叉树的深度的经验之后，很容易想到一个思路：遍历每个结点的时候，得到它的左右结点的深度。如果每个结点的左右二叉树的深度相差都不超过1，就是平衡二叉树。但是这个方法每个结点都被重复遍历，效率不高方法2：自底向上如果我们用后序遍历的方式遍历二叉树的每一个结点，在遍历到一个结点之前我们就已经遍历了它的左右子树。只要在遍历每个结点的时候几下它的深度，就可以一次遍历判断每个结点是不是平衡二叉树。# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def IsBalanced_Solution(self, pRoot): depth = self.get_depth(pRoot) if depth == -1: return False return True def get_depth(self,pRoot): if not pRoot: return 0 left = self.get_depth(pRoot.left) if left == -1: return -1 right = self.get_depth(pRoot.right) if right == -1: return -1 if abs(left-right) &lt;= 1: return max(left,right) + 1 else: return -1 def IsBalanced_Solution(self, pRoot): # write code here if not pRoot: return True left = self.get_depth(pRoot.left) right = self.get_depth(pRoot.right) return abs(left - right) &lt;= 1 and self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right) def get_depth(self, pRoot): if not pRoot: return 0 return max(self.get_depth(pRoot.left), self.get_depth(pRoot.right)) + 1 40、 数组中只出现一次的数字一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。解答：方法：1、考虑数组中只有一个数只出现一次，则将所有数字异或就可以得到这个数。2、两个数不一样，则异或的结果至少有一位为1，我们找到第一个为1的位置，记作n；找到数字k第一个为1的位3、根据第n为是否为1的标准可以将数组分为2个部分，这两个只出现一次的数就分别在这两个部分中，在通过异或即可得到结果# -*- coding:utf-8 -*- class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here res = 0 for i in array: res ^= i index = self.get_index(res) num0 = num1 = 0 for i in array: if self.get_sep(i,index) == 0: num0 ^= i else: num1 ^= i return num0,num1 def get_index(self,k): index = 0 while k & 1 == 0: k = k >> 1 index += 1 return index def get_sep(self,k,index): k = k >> index return k & 1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>编程实践</category>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer（21-30）]]></title>
    <url>%2F20190524-sword-to-offer-3.html</url>
    <content type="text"><![CDATA[21、栈的压入、弹出序列输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）解答：# 【思路】借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，# 这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，# 这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。# 举例：# 入栈1,2,3,4,5# 出栈4,5,3,2,1# 首先1入辅助栈，此时栈顶1≠4，继续入栈2# 此时栈顶2≠4，继续入栈3# 此时栈顶3≠4，继续入栈4# 此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3# 此时栈顶3≠5，继续入栈5# 此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3# ….# 依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序class Solution: def IsPopOrder(self, pushV, popV): stack = [] if len(pushV) != len(popV): return False for i in range(len(pushV)): stack.append(pushV[i]) while len(stack)>0 and stack[-1] == popV[0]: stack.pop() popV.pop(0) if len(popV): return False return True 22、从上往下打印二叉树从上往下打印出二叉树的每个节点，同层节点从左至右打印。解答：方法：实际就是广度优先遍历，二叉树的层次遍历。利用一个辅助队列，首先将根节点压入队列，然后弹出队列，将根节点值append到result，然后将根节点的左右子树分别压入队列。# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here if not root: return [] stack = [] res = [] stack.append(root) while stack: node = stack.pop(0) res.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return res 23、 二叉搜索树的后序遍历序列输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。解答：方法1：递归方法。二叉搜索树，左子树不大于根节点，右子树不小于根节点。后序遍历序列，则sequence[-1]为根节点，遍历序列找到的第一个大于根节点的数就是右子树的开始，前面的数都是左子树。注意判断右子树中有没有小于根节点的数，若存在返回False。然后判断左右子树是否存在，存在则递归判断。最后返回左右子树标记的与结果。注意，序列长为0放回False，序列长为1返回True方法2：非递归方法。类似递归的思想，遍历序列判断出第一个大于根节点的数，由于左子树一定小于右子树，可以将左子树看做右子树的左子树，直接判断右子树是否符合要求即可# -*- coding:utf-8 -*- class Solution: def VerifySquenceOfBST(self, sequence): # write code here if not sequence: return False if len(sequence) == 1: return True root = sequence[-1] k = 0 for i in range(len(sequence)): if sequence[i] >= root: k = i break for i in range(k, len(sequence) - 1): if sequence[i] &lt; root: return False left = sequence[:k] right = sequence[k:-2] left_tag = True right_tag = True if left: left_tag = self.VerifySquenceOfBST(left) if right: right_tag = self.VerifySquenceOfBST(right) return left_tag and right_tag def VerifySquenceOfBST(self, sequence): # write code here if not sequence: return False if len(sequence) == 1: return True i = 0 n = len(sequence) while n: while sequence[i] &lt; sequence[n - 1]: i += 1 while sequence[i] > sequence[n - 1]: i += 1 n -= 1 if i &lt; n: return False i = 0 return True 24、 二叉树中和为某一值的路径输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)解答：方法：递归方法叶节点是叶子节点，度为0。深度优先遍历。递归先序遍历树，把结点加入路径。若该结点是叶子结点则比较当前路径和是否等于期待和。弹出结点，每一轮递归返回到父结点时，当前路径也应该回退一个结点注意：在判断等于期待和后，每次需要新建一个list，否则至始至终result_list都指向同一个list。target在递归中就是他所在那层的值，下一层递归所改变的值不会递归到上一层，pop后不需要加回去。# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: # 返回二维列表，内部每个列表表示找到的路径 def __init__(self): self.result_list = [] self.tmp_list = [] def FindPath(self, root, expectNumber): # write code here if not root: return self.tmp_list self.tmp_list.append(root.val) expectNumber -= root.val if expectNumber == 0 and not root.left and not root.right: new_list = [] for i in self.tmp_list: new_list.append(i) self.result_list.append(new_list) self.FindPath(root.left,expectNumber) self.FindPath(root.right,expectNumber) self.tmp_list.pop() return self.result_list 25、复杂链表的复制输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空解答：方法1：三步法：*1、遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；*2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;*3、拆分链表，将链表拆分为原链表和复制后的链表方法2：递归法。直接复制原链表，但是复制链表random指向的是原复杂链表# -*- coding:utf-8 -*- # class RandomListNode: # def __init__(self, x): # self.label = x # self.next = None # self.random = None class Solution: # 返回 RandomListNode def Clone(self, pHead): # write code here if not pHead: return curHead = pHead while curHead: node = RandomListNode(curHead.label) node.next = curHead.next curHead.next = node curHead = node.next curHead = pHead while curHead: node = curHead.next if curHead.random: node.random = curHead.random.next curHead = node.next curHead = pHead copHead = pHead.next while curHead.next: tmp = curHead.next curHead.next = tmp.next curHead = tmp return copHead # curhead = pHead # cophead = pHead.next # tmp = pHead.next # while curhead.next: # curhead.next = tmp.next # curhead = tmp # tmp = tmp.next # return cophead def Clone(self, pHead): # write code here if not pHead: return curhead = pHead cophead = RandomListNode(curhead.label) cophead.next = curhead.next cophead.random = curhead.random cophead.next = self.Clone(curhead.next) return cophead 26、二叉搜索树与双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。解答：方法1：递归1、将左子树构造成双链表，并返回链表头节点。2、定位至左子树双链表最后一个节点。3、如果左子树链表不为空的话，将当前root追加到左子树链表。4、将右子树构造成双链表，并返回链表头节点。5、如果右子树链表不为空的话，将该链表追加到root节点之后。6、根据左子树链表是否为空确定返回的节点。方法2：非递归1、核心是中序遍历的非递归算法。2、修改当前遍历节点与前一遍历节点的指针指向。# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def Convert(self, pRootOfTree): # write code here if not pRootOfTree: return if not pRootOfTree.left and not pRootOfTree: return pRootOfTree left = self.Convert(pRootOfTree.left) node = left while left and node.right: node = node.right if left: node.right = pRootOfTree pRootOfTree.left = node right = self.Convert(pRootOfTree.right) if right: pRootOfTree.right = right right.left =pRootOfTree if left: return left else: return pRootOfTree def Convert(self, pRootOfTree): # write code here if not pRootOfTree: return if not pRootOfTree.left and not pRootOfTree: return pRootOfTree node = pRootOfTree stack = [] res_stack = [] while node or stack: while node: stack.append(node) node = node.left node = stack.pop() res_stack.append(node) node = node.right result = res_stack[0] while res_stack: top = res_stack.pop(0) if res_stack: top.right = res_stack[0] res_stack[0].left = top return result 27、字符串的排列输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。解答：方法1：基于回溯法思想递归的思想，进行全排列，解析方法2：字典序全排列算法，解析# -*- coding:utf-8 -*- class Solution: def __init__(self): self.result = [] def Permutation(self, ss): ss = list(ss) begin = 0 end = len(ss) - 1 self.Permutation_Part(ss, begin, end) return sorted(self.result) def Permutation_Part(self, ss, begin, end): if begin == end: self.result.append(''.join(ss)) return for i in range(begin, end + 1): if self.is_swap(ss, begin, i): ss[begin], ss[i] = ss[i], ss[begin] self.Permutation_Part(ss, begin + 1, end) ss[begin], ss[i] = ss[i], ss[begin] def is_swap(self, ss, begin, k): for i in range(begin, k): if ss[i] == ss[k]: return False return True class Solutin(): def Permutation(self, ss): # write code here ss = list(ss) ss_len = len(ss) if ss_len == 0: return [] result = [] result.append(''.join(ss)) while True: i = ss_len - 1 while ss[i - 1] >= ss[i] and i >= 1: i -= 1 if i == 0: break m = i while m &lt; ss_len and ss[m] > ss[i - 1] : m += 1 ss[m - 1], ss[i - 1] = ss[i - 1], ss[m - 1] ss[i:] = sorted(ss[i:]) result.append(''.join(ss)) return result 28、数组中出现次数超过一半的数字数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。解答：方法1：利用字典存储，在遍历中进行判断value是否大于数组的一半，时间复杂度O(n)，空间复杂度O(n)方法2：有一个士兵和他自己打架就赢一分，和别人打架就输一分，他的分数是零就出局了。从下一个排号的开始（也可能是他自己）再进行以上，一直比到最后还有分的那个，就可能是胜利者（如果这个胜利者是恰巧赢了那几局，就说明那个出现最多的那个士兵并不存在，所以最后重新计数）时间复杂度O(2*n)，空间复杂度O(1)# -*- coding:utf-8 -*- class Solution: def MoreThanHalfNum_Solution(self, numbers): # write code here number_len = len(numbers) number_dict = {} res = [] for i in range(number_len): if numbers[i] not in number_dict: number_dict[numbers[i]] = 0 number_dict[numbers[i]] += 1 if number_dict[numbers[i]] > int(number_len / 2): return numbers[i] return 0 def MoreThanHalfNum_Solution(self, numbers): # write code here if len(numbers) == 0: return 0 numbers_len = len(numbers) tag = numbers[0] count = 1 for i in range(1,numbers_len): if numbers[i] == tag: count +=1 else: count -= 1 if count == 0: tag = numbers[i] count = 1 count = 0 for i in numbers: if i == tag: count += 1 if count > int(numbers_len / 2): return tag return 0 29、最小的K个数输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。解答：方法：主要考虑的是海量数据下内存不够的情况，使用堆排序，求最小的K个数，则建立K个数的大顶堆，时间复杂度为O(KlogK)，将剩余的元素和堆顶元素比较，小于堆顶元素的进行替换，并刷新大顶堆。最终时间复杂度为O(NlogK)# -*- coding:utf-8 -*- class Solution: def GetLeastNumbers_Solution(self, tinput, k): if len(tinput) &lt; k or k == 0: return [] min_input = tinput[:k] self.HeapSort(min_input) for i in tinput[k:]: if i &lt; min_input[0]: min_input[0] = i self.HeapSort(min_input) return min_input[::-1] def HeapSort(self,min_input): k = len(min_input) i = int(k / 2) - 1 while i >= 0: self.HeapAdjust(min_input, i, k) i -= 1 j = k - 1 while j > 0: min_input[0], min_input[j] = min_input[j], min_input[0] self.HeapAdjust(min_input, 0, j) j = j - 1 return min_input def HeapAdjust(self,min_input,i,n): j = i * 2 + 1 tag = min_input[i] while j &lt; n: if j &lt; n - 1 and min_input[j] > min_input[j+1]: j = j + 1 if min_input[j] &lt; tag: min_input[i] = min_input[j] i = j else: break j = j * 2 + 1 min_input[i] = tag 30、连续子数组的最大和HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)解答：方法：动态规划# -*- coding:utf-8 -*- class Solution: def FindGreatestSumOfSubArray(self, array): # write code here res = array[0] tmp = array[0] for i in range(1,len(array)): tmp = max(tmp + array[i],array[i]) res = max(res,tmp) return res document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>编程实践</category>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer（11-20）]]></title>
    <url>%2F20190524-sword-to-offer-2.html</url>
    <content type="text"><![CDATA[11、二进制中1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。解答：方法：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。# -*- coding:utf-8 -*- class Solution: def NumberOf1(self, n): # write code here if n == 0: return 0 elif n > 0: tag = 0 while n != 0: tag += 1 n = n & (n-1) return tag else: n = 2**32 + n tag = 0 while n != 0: tag += 1 n = n & (n-1) return tag 12、数值的整数次方给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。解答：方法：快速幂。举例:13表示为二进制为110110^1101 = 10^000110^010010^1000。2^13 = 2^8 2^4 2^12^8 = 2^4 * 2^42^4 = 2^2 * 2^22^2 = 2^1 * 2^1右移运算代替除以2；位与运算代替取余，判断奇数和偶数。# -*- coding:utf-8 -*- class Solution: def Power(self, base, exponent): # write code here if abs(base) &lt; 1e-15 and exponent &lt; 0: return False elif exponent == 0: return 1 abs_exponent = abs(exponent) result = 1.0 tmp_base = base while abs_exponent != 0: if (abs_exponent & 1) == 1: result *= tmp_base tmp_base *= tmp_base abs_exponent = abs_exponent >> 1 if exponent > 0: return result else: return 1 / result 13、调整数组顺序使奇数位于偶数前面输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。解答：方法1：以时间换空间，时间复杂度O(n^2)，空间复杂度O(1)。类似冒泡算法，前偶后奇就交换。方法2：新建两个列表，时间复杂度O(n)，空间复杂度O(n)# -*- coding:utf-8 -*- class Solution: def reOrderArray(self, array): # write code here n = len(array) for i in range(n): j = n - 1 while j > i: if array[j]&1 == 1 and array[j-1]&1 == 0: array[j-1],array[j] = array[j],array[j-1] j -= 1 return array def reOrderArray(self, array): # write code here n = len(array) j = 0 for i in range(n): if (array[j]&1) == 0: array.append(array[j]) del array[j] j += 1 return array 14、链表中倒数第k个结点输入一个链表，输出该链表中倒数第k个结点。解答：方法1：设置两个指针pre和last都指向head，last先向后移动k个位置，然后pre和last一直向后移动至last为空，pre即为倒数第k个结点。方法2：将链表的结点append到list中，所求即list的倒数第k位注意：count的作用是判断k的值是否大于链表长度，因为链表无法直接计算长度。# -*- coding:utf-8 -*- # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def FindKthToTail(self, head, k): # write code here if head is None or k &lt; 1: return None pre = head last = head num = k count = 0 while last is not None: last = last.next count += 1 if num &lt; 1: pre = pre.next num -= 1 if count &lt; k: return None return pre def FindKthToTail(self, head, k): # write code here if head is None: return else: tmp = [] while head: tmp.append(head) head = head.next if k > len(tmp) or k &lt; 1: return return tmp[-k] 15、反转链表输入一个链表，反转链表后，输出新链表的表头。解答：方法：利用三个指针实现，pre，pHead，nex。1、nex保存pHead.next的结点信息，保证后面的链表信息不会消失；2、将pre和pHead反转链表，使pHead.next=pre；3、最后将pre，pHead，nex全部向后移动一位。4、直至pHead为空，则pre为最后一个结点，记录了反转链表的所有信息，即为所求。# -*- coding:utf-8 -*- # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead pre = None nex = None while pHead: nex = pHead.next pHead.next = pre pre = pHead pHead = nex return pre 16、合并两个排序的链表输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。解答：方法1：递归方法，递归中直接pHead = None，pHead = pHead1即可方法2：非递归方法，比较pHead1.val和pHead2.val，较小的放入pHead。非递归中创建链表需pHead = ListNode(-1)，pHead.next = None，root = PHead。最后返回链表是root.next，不加.next会将开始的根节点val=-1加进去。注意空链表的情况# -*- coding:utf-8 -*- # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # write code here if pHead1 is None: return pHead2 elif pHead2 is None: return pHead1 if pHead1.val &lt;= pHead2.val: pHead = pHead1 pHead.next = self.Merge(pHead1.next, pHead2) else: pHead = pHead2 pHead.next = self.Merge(pHead1, pHead2.next) return pHead def Merge(self, pHead1, pHead2): # write code here if pHead1 is None: return pHead2 elif pHead2 is None: return pHead1 pHead = ListNode(None) root = pHead #root的作用记录pHead，不能直接返回pHead，因为最后的pHead只指向最后一个元素 while pHead1 and pHead2: if pHead1.val &lt;= pHead2.val: pHead.next = pHead1 pHead1 = pHead1.next else: pHead.next = pHead2 pHead2 = pHead2.next pHead = pHead.next if pHead1: pHead.next = pHead1 elif pHead2: pHead.next = pHead2 return root.next 17、树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）解答：方法：# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False return self.is_Subtree(pRoot1,pRoot2) or self.is_Subtree(pRoot1.left,pRoot2) or self.is_Subtree(pRoot1.right,pRoot2) def is_Subtree(self,A,B): if not B: return True if not A or A.val != B.val: return False return self.is_Subtree(A.left,B.left) and self.is_Subtree(A.right,B.right) 18、二叉树的镜像操作给定的二叉树，将其变换为源二叉树的镜像解答：方法1：递归方法。将根节点的左右子树交换位置，然后分别进行递归镜像函数。因为左右子树包含了其下所有子树的信息。方法2：非递归方法。利用栈和队列的思想，在python中利用list实现，首先将根节点append到list中；然后将其pop到一个新建树中，将左右子树交换位置；然后分别将交换位置后得到的左右子树push压入list，即insert(0,p.left)。在while len(st)>0的循环中，st.pop(0)和st.pop()结果相同，由于根节点的左右子树已经交换位置，后面的子树交换顺序无所谓了。# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: # 返回镜像树的根节点 def Mirror(self, root): if not root: return None if root: root.left,root.right = root.right,root.left self.Mirror(root.left) self.Mirror(root.right) def Mirror(self, root): # write code here if not root: return None st = [] st.append(root) p = TreeNode(None) while len(st)>0: p = st.pop() p.left,p.right = p.right,p.left if p.left: st.append(p.left) if p.right: st.append(p.right) 19、顺时针打印矩阵输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.解答：方法：# 可以模拟魔方逆时针旋转的方法，一直做取出第一行的操作# 例如# 1 2 3# 4 5 6# 7 8 9# 输出并删除第一行后，再进行一次逆时针旋转，就变成：# 6 9# 5 8# 4 7# 继续重复上述操作即可# -*- coding:utf-8 -*- # 可以模拟魔方逆时针旋转的方法，一直做取出第一行的操作 # 例如 # 1 2 3 # 4 5 6 # 7 8 9 # 输出并删除第一行后，再进行一次逆时针旋转，就变成： # 6 9 # 5 8 # 4 7 # 继续重复上述操作即可。 class Solution: # matrix类型为二维列表，需要返回列表 def printMatrix(self, matrix): # write code here result = [] while len(matrix) > 0: result.extend(matrix[0]) matrix.pop(0) if matrix: matrix = self.turn(matrix) return result def turn(self, matrix): r = len(matrix) c = len(matrix[0]) res = [] for i in range(c)[::-1]: tmp = [] for j in range(r): tmp.append(matrix[j][i]) res.append(tmp) return res 20、包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。解答：方法：利用一个辅助栈来存放最小值。栈 3，4，2，5，1辅助栈 3，3，2，2，1每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶；当出栈时，辅助栈也要出栈；这种做法可以保证辅助栈顶一定都当前栈的最小值# -*- coding:utf-8 -*- #思路：利用一个辅助栈来存放最小值 # 栈 3，4，2，5，1 # 辅助栈 3，3，2，2，1 #每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶 #当出栈时，辅助栈也要出栈 #这种做法可以保证辅助栈顶一定都当前栈的最小值 class Solution: def __init__(self): self.stack = [] self.min_stack = [] def push(self, node): # write code here self.stack.append(node) if not self.min_stack or self.min_stack[-1] > node: self.min_stack.append(node) def pop(self): # write code here if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self): # write code here return self.stack[-1] def min(self): # write code here return self.min_stack[-1] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>编程实践</category>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer（1-10）]]></title>
    <url>%2F20190523-sword-to-offer-1.html</url>
    <content type="text"><![CDATA[牛客网剑指offer编程实践1-10题1、二维数组中的查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数解答：方法1：遍历整个二维数组，判断数组中是否含有该整数方法2：从二维数组的左下角tag开始判断，如果目标整数大于tag，tag右移，如果目标整数小于tag，tag上移。如果相等返回Trueclass Solution: # array 二维列表 def Find(self, target, array): for i in array: if target in i: return True return False def Find(self, target, array): raw = len(array) col = len(array[0]) i = raw - 1 j = 0 while i >= 0 and j &lt; col: if array[i][j] &lt; target: j += 1 elif array[i][j] > target: i -= 1 else: return True return False 2、替换空格请实现一个函数，将一个字符串中的每个空格替换成%20。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。解答：方法1：将字符串s变换成list，将list中的空格替换成“%20”，然后将list转换成字符串输出。缺点：不是原来的字符串s方法2：先遍历以便字符串s，判断有多少个空格，然后从后往前开始替换。# -*- coding:utf-8 -*- class Solution: # s 源字符串 def replaceSpace(self, s): # write code here s = list(s) for i in range(len(s)): if s[i] == ' ': s[i] = '%20' return ''.join(s) 3、从尾到头打印链表输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。注意：自定义的listNode函数不能直接使用len()，使用while listNode:解答：方法1：使用一个栈，遍历链表进行进栈，然后出栈到ArrayList方法2：遍历链表到list，然后利用list[::-1]进行输出# -*- coding:utf-8 -*- # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here if listNode is None: return [] tmp = [] while listNode: tmp.append(listNode.val) listNode = listNode.next return tmp[::-1] 4、重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。解答：方法：根据前序遍历第一个元素找到根节点，然后在中序遍历中找到根节点的index，index左边的为根节点的左子树，index右边的为根节点的右子树。然后在两个遍历中截取两个子树进行迭代注意：要返回二叉树，而不是数组，# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if len(pre) == 0: return None else: root = TreeNode(pre[0]) tag = tin.index(pre[0]) root.left = self.reConstructBinaryTree(pre[1:tag+1],tin[0:tag]) root.right = self.reConstructBinaryTree(pre[tag+1:],tin[tag+1:]) return root 5、用两个栈实现队列1、用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。解答：方法：队列的Push操作就是一个栈A的进栈队列的Pop操作，判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；如果不为空，栈B直接出栈。# -*- coding:utf-8 -*- class Solution: def __init__(self): self.stack0 = [] self.stack1 = [] def push(self, node): # write code here return self.stack0.append(node) def pop(self): # return xx #出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；如果不为空，栈B直接出栈。 if self.stack1 == []: while self.stack0: self.stack1.append(self.stack0.pop()) return self.stack1.pop() 2、用两个队列实现一个栈的功能？要求给出算法和思路！方法：入栈：将元素进队列A出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素以此出队列并放入队列B，直到队列A中的元素留下一个，然后队列A出队列，再把队列B中的元素出队列以此放入队列A中。6、旋转数组最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。解答：方法1：遍历整个数组找到最小的元素。方法2：因为是非递减数组旋转，利用二分法进行判断，如果array[mid] > array[0]，则最小元素在mid的右边。找到的第一个小于array[mid]的元素即最小元素如果array[mid] &lt; array[0]，则最小元素在mid的左边。找到的第一个大于array[mid]的元素，它的后一个元素即为最小元素注意数组为0，返回0。# -*- coding:utf-8 -*- class Solution: def minNumberInRotateArray(self, rotateArray): # write code here if len(rotateArray) == 0: return 0 tmp = rotateArray[0] for i in rotateArray: if i &lt; tmp: tmp = i return tmp #时间复杂度为O(lgn)，二分法 def minNumberInRotateArray(self, rotateArray): # write code here if len(rotateArray) == 0: return 0 mid = int((len(rotateArray) - 1) / 2) if rotateArray[mid] >= rotateArray[0]: for i in rotateArray[mid:]: if i &lt; rotateArray[mid]: return i else: for i in reversed(range(mid)): if rotateArray[i] > rotateArray[mid]: return rotateArray[i + 1] 7、斐波那契数列大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39解答：方法：动态规划，一次的结果之和上两个数相关# -*- coding:utf-8 -*- class Solution: def Fibonacci(self, n): # write code here if n == 0: return 0 elif n == 1: return 1 elif n == 2: return 1 else: tag = [] tag.append(1) tag.append(1) for i in range(2,n): tag.append(tag[i-1]+tag[i-2]) return tag[n-1] #从0开始，第0项为0，如果从第一项开始，则为while n > 1: def Fibonacci(self, n): f = 0 s = 1 while n: s = f + s f = s - f n -= 1 return f 8、跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。解答：方法：a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)c.由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2e.可以发现最终得出的是一个斐波那契数列：# -*- coding:utf-8 -*- class Solution: def jumpFloor(self, number): # write code here if number == 1: return 1 elif number == 2: return 2 else: tag = [] tag.append(1) tag.append(2) for i in range(2, number): tag.append(tag[i - 1] + tag[i - 2]) return tag[number-1] def jumpFloor(self, number): f = 1 s = 2 while number > 1: s = f + s f = s - f number -= 1 return f 9、变态跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。解答：方法1：f(1) = 1f(2) = f(2-1) + f(2-2) f(2-2)表示一次跳2级台阶f(3) = f(3-1) + f(3-2) +f(3-3)f(n) = f(n-1) +…+ f(n-(n-1)) + f(n-n)​ = f(0) + f(1) +…+f(n-1)f(n-1) = f(0) + f(1) +…+f(n-2)f(n) = 2*f(n-1)方法2：每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)中情况# -*- coding:utf-8 -*- class Solution: def jumpFloorII(self, number): # write code here return 2**(number-1) def jumpFloorII(self, number): if number &lt;= 0: return -1 elif number == 1: return 1 return 2*self.jumpFloorII(number-1) 10、矩阵覆盖我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？解答:方法：同上面的斐波那契数列，只是f(1) = 1,f(2) = 2# -*- coding:utf-8 -*- class Solution: def rectCover(self, number): # write code here if number == 0: return 0 if number == 1: return 1 elif number == 2: return 2 else: tag = [] tag.append(1) tag.append(2) for i in range(2, number): tag.append(tag[i - 1] + tag[i - 2]) return tag[-1] def rectCover(self, number): if number == 0: return 0 elif number == 1: return 1 elif number == 2: return 2 f = 1 s = 2 while number > 1: s = s + f f = s - f number -= 1 return f document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>编程实践</category>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建git博客]]></title>
    <url>%2F20190520-hexo-blog-optimization.html</url>
    <content type="text"><![CDATA[本文主要内容是本站博客使用Next主题的个性化定制和部分优化细节。最后搭建的博客。开始 Hexo+github搭建个人博客Hexo博客搭建的基础流程为：安装Node.js→安装Git→安装主题→注册给github并创建pages仓库→部署首先可以将Hexo官方文档看一遍，然后可以参考这篇文章使用Hexo+Github一步步搭建属于自己的博客（基础）进行配置。如果想将博客同步到coding上可以查看这篇文章：基于Hexo+Github+Coding搭建个人博客——基础篇(从菜鸟到放弃)。之后在站点文件夹根目录，安装Git部署插件（以后所有安装的插件都在这个目录），输入下面命令：所在目录：~/Blog/ npm install hexo-deployer-git --save 然后在站点根目录下配置文件，编辑：文件位置：~/Blog/_config.yml url: https://cqupt-wan.github.io/ . .省略... . # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: git@github.com:CQUPT-Wan/CQUPT-Wan.github.io.git branch: master # other deployer -type: leancloud_counter_security_sync 将其中的cqupt-wan更改为你的git账号即可，可以执行hexo s在 http://localhost:4000 本地调试成功后，执行 hexo clean && hexo g && hexo d 上传到git博客上。站点根目录内容建立好的站点根目录如下：. ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 每个文件或文件夹的功能如下：_config.yml站点博客的配置文件，博客的名称、关键词、作者、语言、博客主题…设置都在里面。package.json应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。scaffoldsscaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容sourcesource是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。themes放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。优化 基本功能配置更换博客主题两个Hexo主题下载的地方：知乎话题：有哪些好看的 Hexo 主题？Hexo官方：Themes然后使用clone的方式将主题下载，本站博客选用的是Hexo的next主题所在目录：~/Blog/ git clone https://github.com/theme-next/hexo-theme-next themes/next clone完成后，修改配置文件中的theme选项文件位置：~/Blog/_config.yml ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next 此外，可以在主题配置文件中修改next主题的不同风格，本站使用的是Mist风格文件位置：~/Blog/themes/next/_config.yml # --------------------------------------------------------------- # Scheme Settings # --------------------------------------------------------------- # Schemes #cheme: Muse #scheme: Mist #scheme: Pisces scheme: Gemini 设置Menu默认只有首页和归档两个，如果还需要添加其他，需要修改主题配置文件：文件位置：~/Blog/themes/next/_config.yml menu: home: / || home //首页 about: /about/ || user //关于 tags: /tags/ || tags //标签 categories: /categories/ || th //分类 archives: /archives/ || archive //归档 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 修改完配置文件后，还需要创建对应的文件夹，以tags标签为例所在目录：~/Blog/ hexo new page "tags" 此外，还需要修改对应文件夹中的index.md文件，comment对应后面的评论系统文件位置：~/Blog/source/tags/index.md --- title: 所有标签 date: 2019-05-16 15:12:51 type: "tags" comments: false --- 添加动态背景修改主题配置文件，将enable改为true即可文件位置：~/Blog/themes/next/_config.yml # Canvas-nest # Dependencies: https://github.com/theme-next/theme-next-canvas-nest canvas_nest: enable: true onmobile: true # display on mobile or not color: "0,0,255" # RGB values, use ',' to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines 配置项说明：color ：线条颜色, 默认: '0,0,255'；三个数字分别为(R,G,B)opacity： 线条透明度（0~1）, 默认: 0.5count：线条的总数量, 默认: 99zIndex ：背景的z-index属性，css属性用于控制所在层的位置, 默认: -1添加RSS首先安装Hexo插件所在目录：~/Blog/ npm install --save hexo-generator-feed 编辑站点配置文件文件位置：~/Blog/_config.yml ## Plugins: https://hexo.io/plugins/ plugins: hexo-generate-feed 配置主题文件文件位置：~/Blog/themes/next/_config.yml # Set rss to false to disable feed link. # Leave rss as blank to use site's feed link, and install hexo-generator-feed: `npm install hexo-generator-feed --save`. # Set rss to specific value if you have burned your feed already. rss: /atom.xml 修改链接样式文件位置：~Blog/themes/next/source/css/_common/components/post/post.styl // 文章内链接文本样式 .post-body p a { color: #0593d3; //原始链接颜色 border-bottom: none; border-bottom: 1px solid #0593d3; //底部分割线颜色 &:hover { color: #fc6423; //鼠标经过颜色 border-bottom: none; border-bottom: 1px solid #fc6423; //底部分割线颜色 } } 修改底部标签样式原本的标签是‘#’，感觉很丑，所有将rel="tag">#标签更改为rel="tag">&lt;i class="fa fa-tag"&gt;现在这个样子文件位置：~/Blog/themes/next/layout/_macro/post.swig {% for tag in post.tags %} {{ tag.name }} {% endfor %} 在文章末尾添加“文章结束”标志首先新建passage-end-tag.swig文件所在目录：~/Blog/themes/next/layout/_macro //创建passage-end-tag.swig文件 touch passage-end-tag.swig 编辑该文件文件位置：~/Blog/themes/next/layout/_macro/passage-end-tag.swig {% if not is_index %} -------------本文结束啦感谢您的阅读------------- {% endif %} ; 然后修改post.swig配置文件，在END POST BODY之后添加文件位置：~/Blog/themes/next/layout/_macro\post.swig {% if not is_index %} {% include '../_macro/passage-end-tag.swig' %} {% endif %} 最后修改主题配置文件即可文件位置：~/Blog/themes/next/_config.yml # 文章末尾添加“本文结束”标记 passage_end_tag: enabled: true 设置网站图标Favicon不论是网站的图标还是头像都存储在~/Blog/themes/next/source/images中，只需要将默认的图片替换掉即可文件位置：~/Blog/themes/next/_config.yml favicon: small: /images/pikapika-16-16.png medium: /images/pikapika-32-32.png apple_touch_icon: /images/pikapika.png safari_pinned_tab: /images/pikapika.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 图片转svg在线生成器进阶 高级功能配置添加热度进入LeanCloud官网，进行账号注册。登录后，进入控制台，创建应用，应用名为Hexo如下图所示：创建应用后，点击存储，创建Class，Class命名为Counter，操作如下图所示：查看AppID和AppKey，如下图所示：加入热度符号：文件位置：~/Blog/themes/next/layout/_macro\post.swig {% if theme.leancloud_visitors.enable or (theme.valine.enable and theme.valine.appid and theme.valine.appkey and theme.valine.visitor) %} | {% if theme.post_meta.item_text %} {{ __('post.views') + __('symbol.colon') }} {% endif %} &#x2103; {% endif %} 添加来必力云跟帖功能首先去来必力注册账号，然后进入后台管理系统，如下图所示：拷贝下图中的data-uid编辑主题配置文件，将上面的data-uid粘贴到下面位置文件位置：~/Blog/themes/next/_config.yml # LiveRe comments system # You can get your uid from https://livere.com/insight/myCode (General web site) livere_uid: 当分类、标签、关于等组件需要隐藏评论功能时编辑index.md文件，添加comments将其值设为false:文件位置：~/Blog/source/about title: About Me date: 2019-05-16 16:04:06 type: "about" comments: false 配置网站底部内容底部隐藏Hexo强力驱动设置主题配置文件文件位置：~/Blog/themes/next/_config.yml footer: # Specify the date when the site was setup. If not defined, current year will be used. since: 2019 修改中文内容文件位置：~/Blog/themes/next/languages/zh-CN.yml footer: powered: "由 %s 个人专属" theme: 主题 total_views: 总访问量 total_visitors: 总访客量 打开Blog/themes/next/layout/_partials/footer.swig，修改相应代码。文件位置：~/Blog/themes/next/layout/_partials/footer.swig {% if theme.footer.powered.enable %} {# #}{{ __('footer.powered', next_url('https://github.com/CQUPT-Wan', 'CQUPT-Wan', {class: 'theme-link'})) }}{# #}{% if theme.footer.powered.version %} v{{ hexo_env('version') }}{% endif %} {% endif %} 网站底部字数统计安装hexo插件，切换到根目录：根目录：~/Blog npm install hexo-wordcount --save 在~/Blog/themes/next/layout/_partials/footer.swig添加代码：注意这段代码添加的位置和底部最后显示的位置相关，我是加在author后面 文件位置：~/Blog/themes/next/layout/_partials/footer.swig {{ theme.footer.copyright || author }} | 博客全站共{{ totalcount(site) }}字 让页脚的心跳动起来首先编辑主题配置文件文件位置：~/Blog/themes/next/_config.yml icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: heart 然后编辑 文件位置：~/Blog/themes/next/layout/_partials/footer.swig 最后编辑custom.styl，加入：文件位置：~/Blog/themes/next/source/css/_custom/custom.styl // 自定义页脚跳动的心样式 @keyframes heartAnimate { 0%,100%{transform:scale(1);} 10%,30%{transform:scale(0.9);} 20%,40%,60%,80%{transform:scale(1.1);} 50%,70%{transform:scale(1.1);} } #heart { animation: heartAnimate 1.33s ease-in-out infinite; } .with-love { color: rgb(255, 0, 0); } 添加DaoVoice在线联系首先到DaoVoice注册账号，登录成过后，进入到后台管理，点击应用设置——>安装到网站查看安装代码和AppID。将安装代码添加到Blog/themes/next/layout/_partials/head.swig中：文件位置：~/Blog/themes/next/layout/_partials/head.swig {% if theme.daovoice %} !function(e,t,o,i,a,c,n){e.DaoVoiceObject=a,e[a]=e[a]||function(){(e[a].q=e[a].q||[]).push(arguments)},e[a].l=1*new Date,c=t.createElement(o),n=t.getElementsByTagName(o)[0],c.async=1,c.src=i,c.charset="utf-8",n.parentNode.insertBefore(c,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"{{theme.daovoice_app_id}}"}),daovoice("update") {% endif %} 配置主题文件文件位置：~/Blog/themes/next/_config.yml # Online contact daovoice: true daovoice_app_id: ab02c609 Hexo博客添加站内搜索NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。安装 hexo-generator-search目录：~/Blog npm install hexo-generator-search --save 安装 hexo-generator-searchdb目录：~/Blog npm install hexo-generator-searchdb --save 编辑站点配置文件文件位置：~/Blog/_config.yml # 搜索 search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，设置Local searchenable为ture文件位置：~/Blog/themes/next/_config.yml # Local search # Dependencies: https://github.com/theme-next/hexo-generator-searchdb local_search: enable: true # If auto, trigger search by changing input. # If manual, trigger search by pressing enter key or search button. trigger: auto # Show top n results per article, show all results by setting to -1 top_n_per_article: 1 # Unescape html strings to the readable one. unescape: false 文章底部添加版权声明在目录 ~/Blog/themes/next/layout/_macro/ 下添加 my-copyright.swig ，内容如下：文件位置：~/Blog/themes/next/layout/_macro/my-copyright.swig {% if page.copyright %} 本文标题:{{ page.title }} 文章作者:{{ theme.author }} 发布时间:{{ page.date.format("YYYY年MM月DD日 - HH:MM") }} 最后更新:{{ page.updated.format("YYYY年MM月DD日 - HH:MM") }} 原始链接:{{ page.permalink }} 许可协议: 署名-非商业性使用-禁止演绎 4.0 国际 转载请保留原文链接及作者。 var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})}) {% endif %} 在目录~/Blog/themes/next/source/css/_common/components/post/下添加文件my-post-copyright.styl，添加以下代码：文件位置：~/Blog/themes/next/source/css/_common/components/post/my-post-copyright.styl .my_post_copyright { width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4); } .my_post_copyright p{margin:0;} .my_post_copyright span { display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold; } .my_post_copyright .raw { margin-left: 1em; width: 5em; } .my_post_copyright a { color: #808080; border-bottom:0; } .my_post_copyright a:hover { color: #a3d2a3; text-decoration: underline; } .my_post_copyright:hover .fa-clipboard { color: #000; } .my_post_copyright .post-url:hover { font-weight: normal; } .my_post_copyright .copy-path { margin-left: 1em; width: 1em; +mobile(){display:none;} } .my_post_copyright .copy-path:hover { color: #808080; cursor: pointer; } 修改~/Blog/themes/next/layout/_macro/post.swig，在END POST BODY后面添加以下代码：文件位置：~/Blog/themes/next/layout/_macro/post.swig {% if not is_index %} {% include 'my-copyright.swig' %} {% endif %} 在~/Blog/themes/next/source/css/_common/components/post/post.styl文件最后加入下面的代码：@import "my-post-copyright"修改网站url因为写的博客存在中文标题，如果直接用默认的url会出现中文，这样容易出现网址Bug。修改方式如下文件位置：~/Blog/_config.yml #permalink: :year/:month/:day/:title/ permalink: :year:month:day-:url_name.html permalink_defaults: url_name: index 这里的url_name需要在每篇新建博客的.md文件中设置你想设置的网址名，如果嫌麻烦可以修改模板文件位置：~/Blog/scaffolds/post.md --- title: {{ title }} url_name: date: {{ date }} tags: categories: copyright: --- 对于标签中的中文，可以编辑站点配置文件进行设定：文件位置：~/Blog/_config.yml # Category & Tag default_category: uncategorized # URL 中的分类和标签「翻译」成英文 category_map: 机器学习: MachineLearning 自然语言处理: NLP 深度学习: DeepLearning 数据结构: DataStructure 编程实践: Coding tag_map: 侧栏加入已运行时间首先加入下面代码文件位置：~/Blog/themes/next/layout/_custom/sidebar.swig function show_date_time(){ window.setTimeout("show_date_time()", 1000); BirthDay=new Date("05/15/2019 15:13:14"); today=new Date(); timeold=(today.getTime()-BirthDay.getTime()); sectimeold=timeold/1000 secondsold=Math.floor(sectimeold); msPerDay=24*60*60*1000 e_daysold=timeold/msPerDay daysold=Math.floor(e_daysold); e_hrsold=(e_daysold-daysold)*24; hrsold=setzero(Math.floor(e_hrsold)); e_minsold=(e_hrsold-hrsold)*60; minsold=setzero(Math.floor((e_hrsold-hrsold)*60)); seconds=setzero(Math.floor((e_minsold-minsold)*60)); document.getElementById('days').innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"; } function setzero(i){ if (i { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
