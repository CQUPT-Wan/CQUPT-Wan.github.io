<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer（11-20）]]></title>
    <url>%2F20190524-sword-to-offer-2.html</url>
    <content type="text"><![CDATA[11、二进制中1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。解答：方法：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。# -*- coding:utf-8 -*- class Solution: def NumberOf1(self, n): # write code here if n == 0: return 0 elif n > 0: tag = 0 while n != 0: tag += 1 n = n & (n-1) return tag else: n = 2**32 + n tag = 0 while n != 0: tag += 1 n = n & (n-1) return tag 12、数值的整数次方给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。解答：方法：快速幂。举例:13表示为二进制为110110^1101 = 10^000110^010010^1000。2^13 = 2^8 2^4 2^12^8 = 2^4 * 2^42^4 = 2^2 * 2^22^2 = 2^1 * 2^1右移运算代替除以2；位与运算代替取余，判断奇数和偶数。# -*- coding:utf-8 -*- class Solution: def Power(self, base, exponent): # write code here if abs(base) &lt; 1e-15 and exponent &lt; 0: return False elif exponent == 0: return 1 abs_exponent = abs(exponent) result = 1.0 tmp_base = base while abs_exponent != 0: if (abs_exponent & 1) == 1: result *= tmp_base tmp_base *= tmp_base abs_exponent = abs_exponent >> 1 if exponent > 0: return result else: return 1 / result 13、调整数组顺序使奇数位于偶数前面输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。解答：方法1：以时间换空间，时间复杂度O(n^2)，空间复杂度O(1)。类似冒泡算法，前偶后奇就交换。方法2：新建两个列表，时间复杂度O(n)，空间复杂度O(n)# -*- coding:utf-8 -*- class Solution: def reOrderArray(self, array): # write code here n = len(array) for i in range(n): j = n - 1 while j > i: if array[j]&1 == 1 and array[j-1]&1 == 0: array[j-1],array[j] = array[j],array[j-1] j -= 1 return array def reOrderArray(self, array): # write code here n = len(array) j = 0 for i in range(n): if (array[j]&1) == 0: array.append(array[j]) del array[j] j += 1 return array 14、链表中倒数第k个结点输入一个链表，输出该链表中倒数第k个结点。解答：方法1：设置两个指针pre和last都指向head，last先向后移动k个位置，然后pre和last一直向后移动至last为空，pre即为倒数第k个结点。方法2：将链表的结点append到list中，所求即list的倒数第k位注意：count的作用是判断k的值是否大于链表长度，因为链表无法直接计算长度。# -*- coding:utf-8 -*- # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def FindKthToTail(self, head, k): # write code here if head is None or k &lt; 1: return None pre = head last = head num = k count = 0 while last is not None: last = last.next count += 1 if num &lt; 1: pre = pre.next num -= 1 if count &lt; k: return None return pre def FindKthToTail(self, head, k): # write code here if head is None: return else: tmp = [] while head: tmp.append(head) head = head.next if k > len(tmp) or k &lt; 1: return return tmp[-k] 15、反转链表输入一个链表，反转链表后，输出新链表的表头。解答：方法：利用三个指针实现，pre，pHead，nex。1、nex保存pHead.next的结点信息，保证后面的链表信息不会消失；2、将pre和pHead反转链表，使pHead.next=pre；3、最后将pre，pHead，nex全部向后移动一位。4、直至pHead为空，则pre为最后一个结点，记录了反转链表的所有信息，即为所求。# -*- coding:utf-8 -*- # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead pre = None nex = None while pHead: nex = pHead.next pHead.next = pre pre = pHead pHead = nex return pre 16、合并两个排序的链表输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。解答：方法1：递归方法，递归中直接pHead = None，pHead = pHead1即可方法2：非递归方法，比较pHead1.val和pHead2.val，较小的放入pHead。非递归中创建链表需pHead = ListNode(-1)，pHead.next = None，root = PHead。最后返回链表是root.next，不加.next会将开始的根节点val=-1加进去。注意空链表的情况# -*- coding:utf-8 -*- # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # write code here if pHead1 is None: return pHead2 elif pHead2 is None: return pHead1 if pHead1.val &lt;= pHead2.val: pHead = pHead1 pHead.next = self.Merge(pHead1.next, pHead2) else: pHead = pHead2 pHead.next = self.Merge(pHead1, pHead2.next) return pHead def Merge(self, pHead1, pHead2): # write code here if pHead1 is None: return pHead2 elif pHead2 is None: return pHead1 pHead = ListNode(None) root = pHead #root的作用记录pHead，不能直接返回pHead，因为最后的pHead只指向最后一个元素 while pHead1 and pHead2: if pHead1.val &lt;= pHead2.val: pHead.next = pHead1 pHead1 = pHead1.next else: pHead.next = pHead2 pHead2 = pHead2.next pHead = pHead.next if pHead1: pHead.next = pHead1 elif pHead2: pHead.next = pHead2 return root.next 17、树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）解答：方法：# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False return self.is_Subtree(pRoot1,pRoot2) or self.is_Subtree(pRoot1.left,pRoot2) or self.is_Subtree(pRoot1.right,pRoot2) def is_Subtree(self,A,B): if not B: return True if not A or A.val != B.val: return False return self.is_Subtree(A.left,B.left) and self.is_Subtree(A.right,B.right) 18、二叉树的镜像操作给定的二叉树，将其变换为源二叉树的镜像解答：方法1：递归方法。将根节点的左右子树交换位置，然后分别进行递归镜像函数。因为左右子树包含了其下所有子树的信息。方法2：非递归方法。利用栈和队列的思想，在python中利用list实现，首先将根节点append到list中；然后将其pop到一个新建树中，将左右子树交换位置；然后分别将交换位置后得到的左右子树push压入list，即insert(0,p.left)。在while len(st)>0的循环中，st.pop(0)和st.pop()结果相同，由于根节点的左右子树已经交换位置，后面的子树交换顺序无所谓了。# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: # 返回镜像树的根节点 def Mirror(self, root): if not root: return None if root: root.left,root.right = root.right,root.left self.Mirror(root.left) self.Mirror(root.right) def Mirror(self, root): # write code here if not root: return None st = [] st.append(root) p = TreeNode(None) while len(st)>0: p = st.pop() p.left,p.right = p.right,p.left if p.left: st.append(p.left) if p.right: st.append(p.right) 19、顺时针打印矩阵输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.解答：方法：# 可以模拟魔方逆时针旋转的方法，一直做取出第一行的操作# 例如# 1 2 3# 4 5 6# 7 8 9# 输出并删除第一行后，再进行一次逆时针旋转，就变成：# 6 9# 5 8# 4 7# 继续重复上述操作即可# -*- coding:utf-8 -*- # 可以模拟魔方逆时针旋转的方法，一直做取出第一行的操作 # 例如 # 1 2 3 # 4 5 6 # 7 8 9 # 输出并删除第一行后，再进行一次逆时针旋转，就变成： # 6 9 # 5 8 # 4 7 # 继续重复上述操作即可。 class Solution: # matrix类型为二维列表，需要返回列表 def printMatrix(self, matrix): # write code here result = [] while len(matrix) > 0: result.extend(matrix[0]) matrix.pop(0) if matrix: matrix = self.turn(matrix) return result def turn(self, matrix): r = len(matrix) c = len(matrix[0]) res = [] for i in range(c)[::-1]: tmp = [] for j in range(r): tmp.append(matrix[j][i]) res.append(tmp) return res 20、包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。解答：方法：利用一个辅助栈来存放最小值。栈 3，4，2，5，1辅助栈 3，3，2，2，1每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶；当出栈时，辅助栈也要出栈；这种做法可以保证辅助栈顶一定都当前栈的最小值# -*- coding:utf-8 -*- #思路：利用一个辅助栈来存放最小值 # 栈 3，4，2，5，1 # 辅助栈 3，3，2，2，1 #每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶 #当出栈时，辅助栈也要出栈 #这种做法可以保证辅助栈顶一定都当前栈的最小值 class Solution: def __init__(self): self.stack = [] self.min_stack = [] def push(self, node): # write code here self.stack.append(node) if not self.min_stack or self.min_stack[-1] > node: self.min_stack.append(node) def pop(self): # write code here if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self): # write code here return self.stack[-1] def min(self): # write code here return self.min_stack[-1] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>编程实践</category>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer（1-10）]]></title>
    <url>%2F20190523-sword-to-offer-1.html</url>
    <content type="text"><![CDATA[牛客网剑指offer编程实践1-10题1、二维数组中的查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数解答：方法1：遍历整个二维数组，判断数组中是否含有该整数方法2：从二维数组的左下角tag开始判断，如果目标整数大于tag，tag右移，如果目标整数小于tag，tag上移。如果相等返回Trueclass Solution: # array 二维列表 def Find(self, target, array): for i in array: if target in i: return True return False def Find(self, target, array): raw = len(array) col = len(array[0]) i = raw - 1 j = 0 while i >= 0 and j &lt; col: if array[i][j] &lt; target: j += 1 elif array[i][j] > target: i -= 1 else: return True return False 2、替换空格请实现一个函数，将一个字符串中的每个空格替换成%20。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。解答：方法1：将字符串s变换成list，将list中的空格替换成“%20”，然后将list转换成字符串输出。缺点：不是原来的字符串s方法2：先遍历以便字符串s，判断有多少个空格，然后从后往前开始替换。# -*- coding:utf-8 -*- class Solution: # s 源字符串 def replaceSpace(self, s): # write code here s = list(s) for i in range(len(s)): if s[i] == ' ': s[i] = '%20' return ''.join(s) 3、从尾到头打印链表输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。注意：自定义的listNode函数不能直接使用len()，使用while listNode:解答：方法1：使用一个栈，遍历链表进行进栈，然后出栈到ArrayList方法2：遍历链表到list，然后利用list[::-1]进行输出# -*- coding:utf-8 -*- # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here if listNode is None: return [] tmp = [] while listNode: tmp.append(listNode.val) listNode = listNode.next return tmp[::-1] 4、重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。解答：方法：根据前序遍历第一个元素找到根节点，然后在中序遍历中找到根节点的index，index左边的为根节点的左子树，index右边的为根节点的右子树。然后在两个遍历中截取两个子树进行迭代注意：要返回二叉树，而不是数组，# -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if len(pre) == 0: return None else: root = TreeNode(pre[0]) tag = tin.index(pre[0]) root.left = self.reConstructBinaryTree(pre[1:tag+1],tin[0:tag]) root.right = self.reConstructBinaryTree(pre[tag+1:],tin[tag+1:]) return root 5、用两个栈实现队列1、用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。解答：方法：队列的Push操作就是一个栈A的进栈队列的Pop操作，判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；如果不为空，栈B直接出栈。# -*- coding:utf-8 -*- class Solution: def __init__(self): self.stack0 = [] self.stack1 = [] def push(self, node): # write code here return self.stack0.append(node) def pop(self): # return xx #出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；如果不为空，栈B直接出栈。 if self.stack1 == []: while self.stack0: self.stack1.append(self.stack0.pop()) return self.stack1.pop() 2、用两个队列实现一个栈的功能？要求给出算法和思路！方法：入栈：将元素进队列A出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素以此出队列并放入队列B，直到队列A中的元素留下一个，然后队列A出队列，再把队列B中的元素出队列以此放入队列A中。6、旋转数组最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。解答：方法1：遍历整个数组找到最小的元素。方法2：因为是非递减数组旋转，利用二分法进行判断，如果array[mid] > array[0]，则最小元素在mid的右边。找到的第一个小于array[mid]的元素即最小元素如果array[mid] &lt; array[0]，则最小元素在mid的左边。找到的第一个大于array[mid]的元素，它的后一个元素即为最小元素注意数组为0，返回0。# -*- coding:utf-8 -*- class Solution: def minNumberInRotateArray(self, rotateArray): # write code here if len(rotateArray) == 0: return 0 tmp = rotateArray[0] for i in rotateArray: if i &lt; tmp: tmp = i return tmp #时间复杂度为O(lgn)，二分法 def minNumberInRotateArray(self, rotateArray): # write code here if len(rotateArray) == 0: return 0 mid = int((len(rotateArray) - 1) / 2) if rotateArray[mid] >= rotateArray[0]: for i in rotateArray[mid:]: if i &lt; rotateArray[mid]: return i else: for i in reversed(range(mid)): if rotateArray[i] > rotateArray[mid]: return rotateArray[i + 1] 7、斐波那契数列大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39解答：方法：动态规划，一次的结果之和上两个数相关# -*- coding:utf-8 -*- class Solution: def Fibonacci(self, n): # write code here if n == 0: return 0 elif n == 1: return 1 elif n == 2: return 1 else: tag = [] tag.append(1) tag.append(1) for i in range(2,n): tag.append(tag[i-1]+tag[i-2]) return tag[n-1] #从0开始，第0项为0，如果从第一项开始，则为while n > 1: def Fibonacci(self, n): f = 0 s = 1 while n: s = f + s f = s - f n -= 1 return f 8、跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。解答：方法：a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)c.由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2e.可以发现最终得出的是一个斐波那契数列：# -*- coding:utf-8 -*- class Solution: def jumpFloor(self, number): # write code here if number == 1: return 1 elif number == 2: return 2 else: tag = [] tag.append(1) tag.append(2) for i in range(2, number): tag.append(tag[i - 1] + tag[i - 2]) return tag[number-1] def jumpFloor(self, number): f = 1 s = 2 while number > 1: s = f + s f = s - f number -= 1 return f 9、变态跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。解答：方法1：f(1) = 1f(2) = f(2-1) + f(2-2) f(2-2)表示一次跳2级台阶f(3) = f(3-1) + f(3-2) +f(3-3)f(n) = f(n-1) +…+ f(n-(n-1)) + f(n-n)​ = f(0) + f(1) +…+f(n-1)f(n-1) = f(0) + f(1) +…+f(n-2)f(n) = 2*f(n-1)方法2：每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)中情况# -*- coding:utf-8 -*- class Solution: def jumpFloorII(self, number): # write code here return 2**(number-1) def jumpFloorII(self, number): if number &lt;= 0: return -1 elif number == 1: return 1 return 2*self.jumpFloorII(number-1) 10、矩阵覆盖我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？解答:方法：同上面的斐波那契数列，只是f(1) = 1,f(2) = 2# -*- coding:utf-8 -*- class Solution: def rectCover(self, number): # write code here if number == 0: return 0 if number == 1: return 1 elif number == 2: return 2 else: tag = [] tag.append(1) tag.append(2) for i in range(2, number): tag.append(tag[i - 1] + tag[i - 2]) return tag[-1] def rectCover(self, number): if number == 0: return 0 elif number == 1: return 1 elif number == 2: return 2 f = 1 s = 2 while number > 1: s = s + f f = s - f number -= 1 return f document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>编程实践</category>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建git博客]]></title>
    <url>%2F20190520-hexo-blog-optimization.html</url>
    <content type="text"><![CDATA[本文主要内容是本站博客使用Next主题的个性化定制和部分优化细节。最后搭建的博客。开始 Hexo+github搭建个人博客Hexo博客搭建的基础流程为：安装Node.js→安装Git→安装主题→注册给github并创建pages仓库→部署首先可以将Hexo官方文档看一遍，然后可以参考这篇文章使用Hexo+Github一步步搭建属于自己的博客（基础）进行配置。如果想将博客同步到coding上可以查看这篇文章：基于Hexo+Github+Coding搭建个人博客——基础篇(从菜鸟到放弃)。之后在站点文件夹根目录，安装Git部署插件（以后所有安装的插件都在这个目录），输入下面命令：所在目录：~/Blog/ npm install hexo-deployer-git --save 然后在站点根目录下配置文件，编辑：文件位置：~/Blog/_config.yml url: https://cqupt-wan.github.io/ . .省略... . # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: git@github.com:CQUPT-Wan/CQUPT-Wan.github.io.git branch: master # other deployer -type: leancloud_counter_security_sync 将其中的cqupt-wan更改为你的git账号即可，可以执行hexo s在 http://localhost:4000 本地调试成功后，执行 hexo clean && hexo g && hexo d 上传到git博客上。站点根目录内容建立好的站点根目录如下：. ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 每个文件或文件夹的功能如下：_config.yml站点博客的配置文件，博客的名称、关键词、作者、语言、博客主题…设置都在里面。package.json应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。scaffoldsscaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容sourcesource是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。themes放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。优化 基本功能配置更换博客主题两个Hexo主题下载的地方：知乎话题：有哪些好看的 Hexo 主题？Hexo官方：Themes然后使用clone的方式将主题下载，本站博客选用的是Hexo的next主题所在目录：~/Blog/ git clone https://github.com/theme-next/hexo-theme-next themes/next clone完成后，修改配置文件中的theme选项文件位置：~/Blog/_config.yml ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next 此外，可以在主题配置文件中修改next主题的不同风格，本站使用的是Mist风格文件位置：~/Blog/themes/next/_config.yml # --------------------------------------------------------------- # Scheme Settings # --------------------------------------------------------------- # Schemes #cheme: Muse #scheme: Mist #scheme: Pisces scheme: Gemini 设置Menu默认只有首页和归档两个，如果还需要添加其他，需要修改主题配置文件：文件位置：~/Blog/themes/next/_config.yml menu: home: / || home //首页 about: /about/ || user //关于 tags: /tags/ || tags //标签 categories: /categories/ || th //分类 archives: /archives/ || archive //归档 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 修改完配置文件后，还需要创建对应的文件夹，以tags标签为例所在目录：~/Blog/ hexo new page "tags" 此外，还需要修改对应文件夹中的index.md文件，comment对应后面的评论系统文件位置：~/Blog/source/tags/index.md --- title: 所有标签 date: 2019-05-16 15:12:51 type: "tags" comments: false --- 添加动态背景修改主题配置文件，将enable改为true即可文件位置：~/Blog/themes/next/_config.yml # Canvas-nest # Dependencies: https://github.com/theme-next/theme-next-canvas-nest canvas_nest: enable: true onmobile: true # display on mobile or not color: "0,0,255" # RGB values, use ',' to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines 配置项说明：color ：线条颜色, 默认: '0,0,255'；三个数字分别为(R,G,B)opacity： 线条透明度（0~1）, 默认: 0.5count：线条的总数量, 默认: 99zIndex ：背景的z-index属性，css属性用于控制所在层的位置, 默认: -1添加RSS首先安装Hexo插件所在目录：~/Blog/ npm install --save hexo-generator-feed 编辑站点配置文件文件位置：~/Blog/_config.yml ## Plugins: https://hexo.io/plugins/ plugins: hexo-generate-feed 配置主题文件文件位置：~/Blog/themes/next/_config.yml # Set rss to false to disable feed link. # Leave rss as blank to use site's feed link, and install hexo-generator-feed: `npm install hexo-generator-feed --save`. # Set rss to specific value if you have burned your feed already. rss: /atom.xml 修改链接样式文件位置：~Blog/themes/next/source/css/_common/components/post/post.styl // 文章内链接文本样式 .post-body p a { color: #0593d3; //原始链接颜色 border-bottom: none; border-bottom: 1px solid #0593d3; //底部分割线颜色 &:hover { color: #fc6423; //鼠标经过颜色 border-bottom: none; border-bottom: 1px solid #fc6423; //底部分割线颜色 } } 修改底部标签样式原本的标签是‘#’，感觉很丑，所有将rel="tag">#标签更改为rel="tag">&lt;i class="fa fa-tag"&gt;现在这个样子文件位置：~/Blog/themes/next/layout/_macro/post.swig {% for tag in post.tags %} {{ tag.name }} {% endfor %} 在文章末尾添加“文章结束”标志首先新建passage-end-tag.swig文件所在目录：~/Blog/themes/next/layout/_macro //创建passage-end-tag.swig文件 touch passage-end-tag.swig 编辑该文件文件位置：~/Blog/themes/next/layout/_macro/passage-end-tag.swig {% if not is_index %} -------------本文结束啦感谢您的阅读------------- {% endif %} ; 然后修改post.swig配置文件，在END POST BODY之后添加文件位置：~/Blog/themes/next/layout/_macro\post.swig {% if not is_index %} {% include '../_macro/passage-end-tag.swig' %} {% endif %} 最后修改主题配置文件即可文件位置：~/Blog/themes/next/_config.yml # 文章末尾添加“本文结束”标记 passage_end_tag: enabled: true 设置网站图标Favicon不论是网站的图标还是头像都存储在~/Blog/themes/next/source/images中，只需要将默认的图片替换掉即可文件位置：~/Blog/themes/next/_config.yml favicon: small: /images/pikapika-16-16.png medium: /images/pikapika-32-32.png apple_touch_icon: /images/pikapika.png safari_pinned_tab: /images/pikapika.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 图片转svg在线生成器进阶 高级功能配置添加热度进入LeanCloud官网，进行账号注册。登录后，进入控制台，创建应用，应用名为Hexo如下图所示：创建应用后，点击存储，创建Class，Class命名为Counter，操作如下图所示：查看AppID和AppKey，如下图所示：加入热度符号：文件位置：~/Blog/themes/next/layout/_macro\post.swig {% if theme.leancloud_visitors.enable or (theme.valine.enable and theme.valine.appid and theme.valine.appkey and theme.valine.visitor) %} | {% if theme.post_meta.item_text %} {{ __('post.views') + __('symbol.colon') }} {% endif %} &#x2103; {% endif %} 添加来必力云跟帖功能首先去来必力注册账号，然后进入后台管理系统，如下图所示：拷贝下图中的data-uid编辑主题配置文件，将上面的data-uid粘贴到下面位置文件位置：~/Blog/themes/next/_config.yml # LiveRe comments system # You can get your uid from https://livere.com/insight/myCode (General web site) livere_uid: 当分类、标签、关于等组件需要隐藏评论功能时编辑index.md文件，添加comments将其值设为false:文件位置：~/Blog/source/about title: About Me date: 2019-05-16 16:04:06 type: "about" comments: false 配置网站底部内容底部隐藏Hexo强力驱动设置主题配置文件文件位置：~/Blog/themes/next/_config.yml footer: # Specify the date when the site was setup. If not defined, current year will be used. since: 2019 修改中文内容文件位置：~/Blog/themes/next/languages/zh-CN.yml footer: powered: "由 %s 个人专属" theme: 主题 total_views: 总访问量 total_visitors: 总访客量 打开Blog/themes/next/layout/_partials/footer.swig，修改相应代码。文件位置：~/Blog/themes/next/layout/_partials/footer.swig {% if theme.footer.powered.enable %} {# #}{{ __('footer.powered', next_url('https://github.com/CQUPT-Wan', 'CQUPT-Wan', {class: 'theme-link'})) }}{# #}{% if theme.footer.powered.version %} v{{ hexo_env('version') }}{% endif %} {% endif %} 网站底部字数统计安装hexo插件，切换到根目录：根目录：~/Blog npm install hexo-wordcount --save 在~/Blog/themes/next/layout/_partials/footer.swig添加代码：注意这段代码添加的位置和底部最后显示的位置相关，我是加在author后面 文件位置：~/Blog/themes/next/layout/_partials/footer.swig {{ theme.footer.copyright || author }} | 博客全站共{{ totalcount(site) }}字 让页脚的心跳动起来首先编辑主题配置文件文件位置：~/Blog/themes/next/_config.yml icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: heart 然后编辑 文件位置：~/Blog/themes/next/layout/_partials/footer.swig 最后编辑custom.styl，加入：文件位置：~/Blog/themes/next/source/css/_custom/custom.styl // 自定义页脚跳动的心样式 @keyframes heartAnimate { 0%,100%{transform:scale(1);} 10%,30%{transform:scale(0.9);} 20%,40%,60%,80%{transform:scale(1.1);} 50%,70%{transform:scale(1.1);} } #heart { animation: heartAnimate 1.33s ease-in-out infinite; } .with-love { color: rgb(255, 0, 0); } 添加DaoVoice在线联系首先到DaoVoice注册账号，登录成过后，进入到后台管理，点击应用设置——>安装到网站查看安装代码和AppID。将安装代码添加到Blog/themes/next/layout/_partials/head.swig中：文件位置：~/Blog/themes/next/layout/_partials/head.swig {% if theme.daovoice %} !function(e,t,o,i,a,c,n){e.DaoVoiceObject=a,e[a]=e[a]||function(){(e[a].q=e[a].q||[]).push(arguments)},e[a].l=1*new Date,c=t.createElement(o),n=t.getElementsByTagName(o)[0],c.async=1,c.src=i,c.charset="utf-8",n.parentNode.insertBefore(c,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"{{theme.daovoice_app_id}}"}),daovoice("update") {% endif %} 配置主题文件文件位置：~/Blog/themes/next/_config.yml # Online contact daovoice: true daovoice_app_id: ab02c609 Hexo博客添加站内搜索NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。安装 hexo-generator-search目录：~/Blog npm install hexo-generator-search --save 安装 hexo-generator-searchdb目录：~/Blog npm install hexo-generator-searchdb --save 编辑站点配置文件文件位置：~/Blog/_config.yml # 搜索 search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，设置Local searchenable为ture文件位置：~/Blog/themes/next/_config.yml # Local search # Dependencies: https://github.com/theme-next/hexo-generator-searchdb local_search: enable: true # If auto, trigger search by changing input. # If manual, trigger search by pressing enter key or search button. trigger: auto # Show top n results per article, show all results by setting to -1 top_n_per_article: 1 # Unescape html strings to the readable one. unescape: false 文章底部添加版权声明在目录 ~/Blog/themes/next/layout/_macro/ 下添加 my-copyright.swig ，内容如下：文件位置：~/Blog/themes/next/layout/_macro/my-copyright.swig {% if page.copyright %} 本文标题:{{ page.title }} 文章作者:{{ theme.author }} 发布时间:{{ page.date.format("YYYY年MM月DD日 - HH:MM") }} 最后更新:{{ page.updated.format("YYYY年MM月DD日 - HH:MM") }} 原始链接:{{ page.permalink }} 许可协议: 署名-非商业性使用-禁止演绎 4.0 国际 转载请保留原文链接及作者。 var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})}) {% endif %} 在目录~/Blog/themes/next/source/css/_common/components/post/下添加文件my-post-copyright.styl，添加以下代码：文件位置：~/Blog/themes/next/source/css/_common/components/post/my-post-copyright.styl .my_post_copyright { width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4); } .my_post_copyright p{margin:0;} .my_post_copyright span { display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold; } .my_post_copyright .raw { margin-left: 1em; width: 5em; } .my_post_copyright a { color: #808080; border-bottom:0; } .my_post_copyright a:hover { color: #a3d2a3; text-decoration: underline; } .my_post_copyright:hover .fa-clipboard { color: #000; } .my_post_copyright .post-url:hover { font-weight: normal; } .my_post_copyright .copy-path { margin-left: 1em; width: 1em; +mobile(){display:none;} } .my_post_copyright .copy-path:hover { color: #808080; cursor: pointer; } 修改~/Blog/themes/next/layout/_macro/post.swig，在END POST BODY后面添加以下代码：文件位置：~/Blog/themes/next/layout/_macro/post.swig {% if not is_index %} {% include 'my-copyright.swig' %} {% endif %} 在~/Blog/themes/next/source/css/_common/components/post/post.styl文件最后加入下面的代码：@import "my-post-copyright"修改网站url因为写的博客存在中文标题，如果直接用默认的url会出现中文，这样容易出现网址Bug。修改方式如下文件位置：~/Blog/_config.yml #permalink: :year/:month/:day/:title/ permalink: :year:month:day-:url_name.html permalink_defaults: url_name: index 这里的url_name需要在每篇新建博客的.md文件中设置你想设置的网址名，如果嫌麻烦可以修改模板文件位置：~/Blog/scaffolds/post.md --- title: {{ title }} url_name: date: {{ date }} tags: categories: copyright: --- 对于标签中的中文，可以编辑站点配置文件进行设定：文件位置：~/Blog/_config.yml # Category & Tag default_category: uncategorized # URL 中的分类和标签「翻译」成英文 category_map: 机器学习: MachineLearning 自然语言处理: NLP 深度学习: DeepLearning 数据结构: DataStructure 编程实践: Coding tag_map: 侧栏加入已运行时间首先加入下面代码文件位置：~/Blog/themes/next/layout/_custom/sidebar.swig function show_date_time(){ window.setTimeout("show_date_time()", 1000); BirthDay=new Date("05/15/2019 15:13:14"); today=new Date(); timeold=(today.getTime()-BirthDay.getTime()); sectimeold=timeold/1000 secondsold=Math.floor(sectimeold); msPerDay=24*60*60*1000 e_daysold=timeold/msPerDay daysold=Math.floor(e_daysold); e_hrsold=(e_daysold-daysold)*24; hrsold=setzero(Math.floor(e_hrsold)); e_minsold=(e_hrsold-hrsold)*60; minsold=setzero(Math.floor((e_hrsold-hrsold)*60)); seconds=setzero(Math.floor((e_minsold-minsold)*60)); document.getElementById('days').innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"; } function setzero(i){ if (i { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
