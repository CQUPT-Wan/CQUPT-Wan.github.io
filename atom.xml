<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CQUPT-Wan</title>
  
  <subtitle>I love u 3000 times</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cqupt-wan.github.io/"/>
  <updated>2019-05-24T12:38:10.347Z</updated>
  <id>https://cqupt-wan.github.io/</id>
  
  <author>
    <name>CQUPT-Wan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer（31-40）</title>
    <link href="https://cqupt-wan.github.io/20190524-sword-to-offer-4.html"/>
    <id>https://cqupt-wan.github.io/20190524-sword-to-offer-4.html</id>
    <published>2019-05-24T12:02:36.000Z</published>
    <updated>2019-05-24T12:38:10.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="31、-整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#31、-整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="31、 整数中1出现的次数（从1到n整数中1出现的次数）"></a>31、 整数中1出现的次数（从1到n整数中1出现的次数）</h1><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><p>解答：</p><p>方法：</p><p>设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析</p><p>1、根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i</p><p>2、当i表示百位，且百位对应的数>=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)*100个点的百位为1</p><p>3、当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10*100）+(b+1)，这些点百位对应为1</p><p>4、当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）</p><p>5、综合以上三种情况，当百位对应0或>=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+1</p><p>6、之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位>=2，补8会产生进位位，效果等同于(a/10+1)</p><p><img src="https://wx2.sinaimg.cn/large/005JV1Cwly1g3co6nwokbj30gc06taa2.jpg" alt="image"></p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def NumberOf1Between1AndN_Solution(self, n):        # write code here        i = 1        count = 0        while i &lt;= n:            a = n / i            b = n % i            count = count + (a+8)/10*i + (a%10==1)*(b+1)            i *= 10        return count</code></pre><h1 id="32、把数组排成最小的数"><a href="#32、把数组排成最小的数" class="headerlink" title="32、把数组排成最小的数"></a>32、把数组排成最小的数</h1><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><p>解答：</p><p>方法：比较字符串s1和s2大小时，即比较s1+s2和s2+s1的大小，小的放在前面，比较某一位的字符时，需要将这个位置和其后面所有位置的字符串进行比较。时间复杂度为O(n^2)，注意两点：1、数组为空时要返回‘’；2、数组中全为0时，返回的是0，而不是00000.</p><p><img src="https://ws4.sinaimg.cn/large/005JV1Cwly1g3co6vf469j30hn0bo74g.jpg" alt="image"></p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def PrintMinNumber(self, numbers):        # write code here        if numbers == []:            return ''        for i in range(len(numbers)):            for j in range(i+1,len(numbers)):                tmp0 = int(str(numbers[i]) + str(numbers[j]))                tmp1 = int(str(numbers[j]) + str(numbers[i]))                if tmp0 > tmp1:                    numbers[i],numbers[j] = numbers[j],numbers[i]        res = ''        for i in numbers:            res += str(i)        if int(res) == 0:            return 0        else:            return res</code></pre><h1 id="33、丑数"><a href="#33、丑数" class="headerlink" title="33、丑数"></a>33、丑数</h1><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><p>解答：</p><p>方法1：暴力求解，任何丑数p，2<em>p，3</em>p，5<em>p结果仍是偶数，1是最小的丑数，从1开始，将1</em>2,1<em>3,1</em>5比较，得到的最小丑数2，将得到的丑数2也同样<em>2，</em>3，*5，比较最小的数</p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def GetUglyNumber_Solution(self, index):        # write code here        if index &lt; 7:            return index        res = [0] * index        res[0] = 1        tmp2 = 0        tmp3 = 0        tmp5 = 0        for i in range(1,index):            res[i] = min(res[tmp2]*2,res[tmp3]*3,res[tmp5]*5)            if res[i] == res[tmp2]*2:                tmp2 += 1            if res[i] == res[tmp3]*3:                tmp3 += 1            if res[i] == res[tmp5]*5:                tmp5 += 1        return res[-1]</code></pre><h1 id="34、第一个只出现一次的字符"><a href="#34、第一个只出现一次的字符" class="headerlink" title="34、第一个只出现一次的字符"></a>34、第一个只出现一次的字符</h1><p>在一个字符串(<code>0&lt;=字符串长度&lt;=10000</code>，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p><p>解答：</p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def FirstNotRepeatingChar(self, s):        # write code here        res_dict = {}        for i in range(len(s)):            if s[i] not in res_dict:                res_dict[s[i]] = 0            res_dict[s[i]] += 1        for i in range(len(s)):            if res_dict[s[i]] == 1:                return i        return -1</code></pre><h1 id="35、数组中的逆序对"><a href="#35、数组中的逆序对" class="headerlink" title="35、数组中的逆序对"></a>35、数组中的逆序对</h1><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p><p>解答：</p><p>方法：归并排序，在合并时，当前面的数组值array[i]大于后面数组值array[j]时，则前面</p><p>数组array[i]~array[mid]都是大于array[j]的，count += mid+1 - i</p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def __init__(self):        self.count = 0    def InversePairs(self, data):        if len(data) == 0:            return 0        # write code here        self.MergeSort(data,0,len(data)-1)        return self.count%1000000007    def MergeSort(self,array,low,high):        if low &lt; high:            mid = (low + high) >> 1            self.MergeSort(array,low,mid)            self.MergeSort(array,mid+1,high)            self.count += self.MergeArray(array,low,mid,high)    def MergeArray(self,array,low,mid,high):        i = low        j = mid + 1        tmp = []        count = 0        while i &lt;= mid and j &lt;= high:            if array[i] &lt; array[j]:                tmp.append(array[i])                i += 1            else:                tmp.append(array[j])                j += 1                count += mid - i + 1        while i &lt;= mid:            tmp.append(array[i])            i += 1        while j &lt;= high:            tmp.append(array[j])            j += 1        for k in range(len(tmp)):            array[low + k] = tmp[k]        return count</code></pre><h1 id="36、两个链表的第一个公共结点"><a href="#36、两个链表的第一个公共结点" class="headerlink" title="36、两个链表的第一个公共结点"></a>36、两个链表的第一个公共结点</h1><p>输入两个链表，找出它们的第一个公共结点。</p><p>解答：</p><p>方法1：</p><p><img src="https://wx4.sinaimg.cn/large/005JV1Cwly1g3co75oq17j30db09g74b.jpg" alt="image"></p><p>长度相同有公共结点，第一次就遍历到；没有公共结点，走到尾部NULL相遇，返回NULL<br>长度不同有公共结点，第一遍差值就出来了，第二遍一起到公共结点；没有公共，一起到结尾NULL。</p><p>方法2：</p><p>遍历两个链表，如果链表长度相同，找到第一个相同的结点；不相同时，先将长的链表移动到和短的链表相同长度的位置，然后找到第一个相同的结点</p><pre><code class="lang-python"># -*- coding:utf-8 -*-# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def FindFirstCommonNode(self, pHead1, pHead2):    # write code here        p1 = pHead1        p2 = pHead2        while p1 != p2:            if not p1:                p1 = pHead2            else:                p1 = p1.next            if not p2:                p2 = pHead1            else:                p2 = p2.next        return p1    def FindFirstCommonNode(self, pHead1, pHead2):        # write code here        sum1 = self.get_length(pHead1)        sum2 = self.get_length(pHead2)        if sum1 > sum2:            pHead1 = self.get_equal(pHead1,sum1-sum2)        else:            pHead2 = self.get_equal(pHead2,sum2-sum1)        while pHead1 != pHead2:            pHead1 = pHead1.next            pHead2 = pHead2.next        return pHead1    def get_equal(self,pHead,s):        while s > 0:            pHead = pHead.next            s -= 1        return pHead    def get_length(self,pHead):        summ = 0        while pHead:            pHead = pHead.next            summ += 1        return summ</code></pre><h1 id="37、数字在排序数组中出现的次数"><a href="#37、数字在排序数组中出现的次数" class="headerlink" title="37、数字在排序数组中出现的次数"></a>37、数字在排序数组中出现的次数</h1><p>统计一个数字在排序数组中出现的次数</p><p>解答：</p><p>方法1：</p><p>排序数组是升序排列，且数组中的数都是整数，则可以使用tmp0 = k – 0.5 和tmp1 = k + 0.5两个数，这两个数在数组中都没有，但可以找到第一个大于tmp0和tmp1的数的index，相减就是最后k出现的次数</p><p>方法2：</p><p>如果数组中的数不是整数，则利用二分法找到k值的第一次出现的index和最后一次出现的index；注意考虑没有k值的情况。</p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def GetNumberOfK(self, data, k):        tmp0 = k - 0.5        tmp1 = k + 0.5        count = self.get_index(data,tmp1) - self.get_index(data,tmp0)        return count    def get_index(self,data,k):        begin = 0        end = len(data) - 1        while begin &lt;= end:            mid = (begin + end) >> 1            if data[mid] &lt; k:                begin = mid + 1            elif data[mid] > k :                end = mid - 1        return beginclass Solution:    def GetNumberOfK(self, data, k):        tmp0 = self.get_first(data,k,0,len(data)-1)        tmp1 = self.get_last(data, k, 0, len(data) - 1)        if tmp0 != -1 and tmp1 != -1:            return tmp1 - tmp0 + 1        return 0    def get_first(self,data,k,begin,end):        if begin > end:            return -1        mid = (begin + end) >> 1        if data[mid] > k:            return self.get_first(data,k,begin,mid-1)        elif data[mid] &lt; k:            return self.get_first(data,k,mid+1,end)        elif mid - 1 >= begin and data[mid-1] == k:            return self.get_first(data,k,begin,mid-1)        else:            return mid    def get_last(self,data,k,begin,end):        while begin &lt;= end:            mid = (begin + end) >> 1            if data[mid] > k:                end = mid - 1            elif data[mid] &lt; k:                begin = mid + 1            elif mid + 1 &lt;= end and data[mid+1] == k:                begin = mid + 1            else:                return mid        return -1</code></pre><h1 id="38、-二叉树的深度"><a href="#38、-二叉树的深度" class="headerlink" title="38、 二叉树的深度"></a>38、 二叉树的深度</h1><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><p>解答：</p><p>方法1：</p><p>递归，递归实际也是深度优先的思想（DFS）,时间复杂度为O(lgN),但是空间复杂度最坏为O(N),当二叉树退化为链表的时候。</p><p>方法2：</p><p>非递归，广度优先遍历BFS，时间复杂度O(N)；利用两个辅助值sum_count和count；sum_count记录每层的结点个数，当count == sum_count时说明一层的结点都已经遍历完毕，depth+1</p><pre><code class="lang-python"># -*- coding:utf-8 -*-# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def TreeDepth(self, pRoot):        if not pRoot:            return 0        left = int(self.TreeDepth(pRoot.left))        right = int(self.TreeDepth(pRoot.right))        return max(left,right)+1    def TreeDepth(self, pRoot):        # write code here        if not pRoot:            return 0        stack = []        stack.append(pRoot)        sum_count = 1        count = 0        depth = 0        while stack:            node = stack.pop(0)            count += 1            if node.left:                stack.append(node.left)            if node.right:                stack.append(node.right)            if count == sum_count:                count = 0                sum_count = len(stack)                depth += 1        return depth</code></pre><h1 id="39、平衡二叉树"><a href="#39、平衡二叉树" class="headerlink" title="39、平衡二叉树"></a>39、平衡二叉树</h1><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><p>解答：</p><p>方法1：递归法</p><p>有了求二叉树的深度的经验之后，很容易想到一个思路：遍历每个结点的时候，得到它的左右结点的深度。如果每个结点的左右二叉树的深度相差都不超过1，就是平衡二叉树。</p><p><img src="https://ws3.sinaimg.cn/large/005JV1Cwly1g3co7gayn6j30op0bvq3f.jpg" alt="image"></p><p>但是这个方法每个结点都被重复遍历，效率不高</p><p>方法2：自底向上</p><p>如果我们用后序遍历的方式遍历二叉树的每一个结点，在遍历到一个结点之前我们就已经遍历了它的左右子树。只要在遍历每个结点的时候几下它的深度，就可以一次遍历判断每个结点是不是平衡二叉树。</p><p><img src="https://ws3.sinaimg.cn/large/005JV1Cwly1g3co7rhgs8j30bl0cr3yo.jpg" alt="image"></p><pre><code class="lang-python"># -*- coding:utf-8 -*-# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def IsBalanced_Solution(self, pRoot):        depth = self.get_depth(pRoot)        if depth == -1:            return False        return True    def get_depth(self,pRoot):        if not pRoot:            return 0        left = self.get_depth(pRoot.left)        if left == -1:            return -1        right = self.get_depth(pRoot.right)        if right == -1:            return -1        if abs(left-right) &lt;= 1:            return max(left,right) + 1        else:            return -1    def IsBalanced_Solution(self, pRoot):        # write code here        if not pRoot:            return True        left = self.get_depth(pRoot.left)        right = self.get_depth(pRoot.right)        return abs(left - right) &lt;= 1 and self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right)    def get_depth(self, pRoot):        if not pRoot:            return 0        return max(self.get_depth(pRoot.left), self.get_depth(pRoot.right)) + 1</code></pre><h1 id="40、-数组中只出现一次的数字"><a href="#40、-数组中只出现一次的数字" class="headerlink" title="40、 数组中只出现一次的数字"></a>40、 数组中只出现一次的数字</h1><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><p>解答：</p><p>方法：</p><p>1、考虑数组中只有一个数只出现一次，则将所有数字异或就可以得到这个数。</p><p>2、两个数不一样，则异或的结果至少有一位为1，我们找到第一个为1的位置，记作n；</p><p>找到数字k第一个为1的位</p><p><img src="https://wx2.sinaimg.cn/large/005JV1Cwly1g3co7zgotnj306j04bglg.jpg" alt="image"></p><p>3、根据第n为是否为1的标准可以将数组分为2个部分，这两个只出现一次的数就分别在这两个部分中，在通过异或即可得到结果</p><p><img src="https://ws1.sinaimg.cn/large/005JV1Cwly1g3co85a0g3j307h029a9v.jpg" alt="image"></p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    # 返回[a,b] 其中ab是出现一次的两个数字    def FindNumsAppearOnce(self, array):        # write code here        res = 0        for i in array:            res ^= i        index = self.get_index(res)        num0 = num1 = 0        for i in array:            if self.get_sep(i,index) == 0:                num0 ^= i            else:                num1 ^= i        return num0,num1    def get_index(self,k):        index = 0        while k & 1 == 0:            k = k >> 1            index += 1        return index    def get_sep(self,k,index):        k = k >> index        return k & 1</code></pre><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;31、-整数中1出现的次数（从1到n整数中1出现的次数）&quot;&gt;&lt;a href=&quot;#31、-整数中1出现的次数（从1到n整数中1出现的次数）&quot; class=&quot;headerlink&quot; title=&quot;31、
        
      
    
    </summary>
    
      <category term="编程实践" scheme="https://cqupt-wan.github.io/categories/Coding/"/>
    
      <category term="剑指offer" scheme="https://cqupt-wan.github.io/categories/Coding/Sword-to-Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer（21-30）</title>
    <link href="https://cqupt-wan.github.io/20190524-sword-to-offer-3.html"/>
    <id>https://cqupt-wan.github.io/20190524-sword-to-offer-3.html</id>
    <published>2019-05-24T11:06:54.000Z</published>
    <updated>2019-05-24T12:06:08.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="21、栈的压入、弹出序列"><a href="#21、栈的压入、弹出序列" class="headerlink" title="21、栈的压入、弹出序列"></a>21、栈的压入、弹出序列</h1><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><p>解答：</p><p># 【思路】借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，</p><p># 这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，</p><p># 这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p><p># 举例：</p><p># 入栈1,2,3,4,5</p><p># 出栈4,5,3,2,1</p><p># 首先1入辅助栈，此时栈顶1≠4，继续入栈2</p><p># 此时栈顶2≠4，继续入栈3</p><p># 此时栈顶3≠4，继续入栈4</p><p># 此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3</p><p># 此时栈顶3≠5，继续入栈5</p><p># 此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</p><p># ….</p><p># 依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序</p><pre><code class="lang-python">class Solution:    def IsPopOrder(self, pushV, popV):        stack = []        if len(pushV) != len(popV):            return False        for i in range(len(pushV)):            stack.append(pushV[i])            while len(stack)>0 and stack[-1] == popV[0]:                stack.pop()                popV.pop(0)        if len(popV):            return False        return True</code></pre><h1 id="22、从上往下打印二叉树"><a href="#22、从上往下打印二叉树" class="headerlink" title="22、从上往下打印二叉树"></a>22、从上往下打印二叉树</h1><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p>解答：</p><p>方法：实际就是广度优先遍历，二叉树的层次遍历。利用一个辅助队列，首先将根节点压入队列，然后弹出队列，将根节点值append到result，然后将根节点的左右子树分别压入队列。</p><pre><code class="lang-python"># -*- coding:utf-8 -*-# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    # 返回从上到下每个节点值列表，例：[1,2,3]    def PrintFromTopToBottom(self, root):        # write code here        if not root:            return []        stack = []        res = []        stack.append(root)        while stack:            node = stack.pop(0)            res.append(node.val)            if node.left:                stack.append(node.left)            if node.right:                stack.append(node.right)        return res</code></pre><h1 id="23、-二叉搜索树的后序遍历序列"><a href="#23、-二叉搜索树的后序遍历序列" class="headerlink" title="23、 二叉搜索树的后序遍历序列"></a>23、 二叉搜索树的后序遍历序列</h1><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><p>解答：</p><p>方法1：递归方法。</p><p>二叉搜索树，左子树不大于根节点，右子树不小于根节点。后序遍历序列，则sequence[-1]为根节点，遍历序列找到的第一个大于根节点的数就是右子树的开始，前面的数都是左子树。注意判断右子树中有没有小于根节点的数，若存在返回False。然后判断左右子树是否存在，存在则递归判断。最后返回左右子树标记的与结果。</p><p>注意，序列长为0放回False，序列长为1返回True</p><p>方法2：非递归方法。</p><p>类似递归的思想，遍历序列判断出第一个大于根节点的数，由于左子树一定小于右子树，可以将左子树看做右子树的左子树，直接判断右子树是否符合要求即可</p><p><img src="https://ws2.sinaimg.cn/large/005JV1Cwly1g3cn5jwatnj30dk095t8p.jpg" alt="image"></p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def VerifySquenceOfBST(self, sequence):        # write code here        if not sequence:            return False        if len(sequence) == 1:            return True        root = sequence[-1]        k = 0        for i in range(len(sequence)):            if sequence[i] >= root:                k = i                break        for i in range(k, len(sequence) - 1):            if sequence[i] &lt; root:                return False        left = sequence[:k]        right = sequence[k:-2]        left_tag = True        right_tag = True        if left:            left_tag = self.VerifySquenceOfBST(left)        if right:            right_tag = self.VerifySquenceOfBST(right)        return left_tag and right_tag    def VerifySquenceOfBST(self, sequence):        # write code here        if not sequence:            return False        if len(sequence) == 1:            return True        i = 0        n = len(sequence)        while n:            while sequence[i] &lt; sequence[n - 1]:                i += 1            while sequence[i] > sequence[n - 1]:                i += 1            n -= 1            if i &lt; n:                return False            i = 0        return True</code></pre><h1 id="24、-二叉树中和为某一值的路径"><a href="#24、-二叉树中和为某一值的路径" class="headerlink" title="24、 二叉树中和为某一值的路径"></a>24、 二叉树中和为某一值的路径</h1><p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><p>解答：</p><p>方法：递归方法</p><p>叶节点是叶子节点，度为0。深度优先遍历。</p><p>递归先序遍历树，把结点加入路径。若该结点是叶子结点则比较当前路径和是否等于期待和。弹出结点，每一轮递归返回到父结点时，当前路径也应该回退一个结点</p><p>注意：在判断等于期待和后，每次需要新建一个list，否则至始至终result_list都指向同一个list。</p><p>target在递归中就是他所在那层的值，下一层递归所改变的值不会递归到上一层，pop后不需要加回去。</p><pre><code class="lang-python"># -*- coding:utf-8 -*-# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    # 返回二维列表，内部每个列表表示找到的路径    def __init__(self):        self.result_list = []        self.tmp_list = []    def FindPath(self, root, expectNumber):        # write code here        if not root:            return self.tmp_list        self.tmp_list.append(root.val)        expectNumber -= root.val        if expectNumber == 0 and not root.left and not root.right:            new_list = []            for i in self.tmp_list:                new_list.append(i)            self.result_list.append(new_list)        self.FindPath(root.left,expectNumber)        self.FindPath(root.right,expectNumber)        self.tmp_list.pop()        return self.result_list</code></pre><h1 id="25、复杂链表的复制"><a href="#25、复杂链表的复制" class="headerlink" title="25、复杂链表的复制"></a>25、复杂链表的复制</h1><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空</p><p>解答：</p><p>方法1：三步法：</p><p>*1、遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；</p><p>*2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</p><p>*3、拆分链表，将链表拆分为原链表和复制后的链表</p><p><img src="https://wx2.sinaimg.cn/large/005JV1Cwly1g3cn5x4830j30ct0f040l.jpg" alt="image"></p><p>方法2：递归法。</p><p>直接复制原链表，但是复制链表random指向的是原复杂链表</p><pre><code class="lang-python"># -*- coding:utf-8 -*-# class RandomListNode:#     def __init__(self, x):#         self.label = x#         self.next = None#         self.random = Noneclass Solution:    # 返回 RandomListNode    def Clone(self, pHead):        # write code here        if not pHead:            return        curHead = pHead        while curHead:            node = RandomListNode(curHead.label)            node.next = curHead.next            curHead.next = node            curHead = node.next        curHead = pHead        while curHead:            node = curHead.next            if curHead.random:                node.random = curHead.random.next            curHead = node.next        curHead = pHead        copHead = pHead.next        while curHead.next:            tmp = curHead.next            curHead.next = tmp.next            curHead = tmp        return copHead        # curhead = pHead        # cophead = pHead.next        # tmp = pHead.next        # while curhead.next:        #     curhead.next = tmp.next        #     curhead = tmp        #     tmp = tmp.next        # return cophead    def Clone(self, pHead):        # write code here        if not pHead:            return        curhead = pHead        cophead = RandomListNode(curhead.label)        cophead.next = curhead.next        cophead.random = curhead.random        cophead.next = self.Clone(curhead.next)        return cophead</code></pre><h1 id="26、二叉搜索树与双向链表"><a href="#26、二叉搜索树与双向链表" class="headerlink" title="26、二叉搜索树与双向链表"></a>26、二叉搜索树与双向链表</h1><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p>解答：</p><p>方法1：递归</p><p>1、将左子树构造成双链表，并返回链表头节点。</p><p>2、定位至左子树双链表最后一个节点。</p><p>3、如果左子树链表不为空的话，将当前root追加到左子树链表。</p><p>4、将右子树构造成双链表，并返回链表头节点。</p><p>5、如果右子树链表不为空的话，将该链表追加到root节点之后。</p><p>6、根据左子树链表是否为空确定返回的节点。</p><p>方法2：非递归</p><p>1、核心是中序遍历的非递归算法。</p><p>2、修改当前遍历节点与前一遍历节点的指针指向。</p><pre><code class="lang-python"># -*- coding:utf-8 -*-# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def Convert(self, pRootOfTree):        # write code here        if not pRootOfTree:            return        if not pRootOfTree.left and not pRootOfTree:            return pRootOfTree        left = self.Convert(pRootOfTree.left)        node = left        while left and node.right:            node = node.right        if left:            node.right = pRootOfTree            pRootOfTree.left = node        right = self.Convert(pRootOfTree.right)        if right:            pRootOfTree.right = right            right.left =pRootOfTree        if left:            return left        else:            return pRootOfTree    def Convert(self, pRootOfTree):        # write code here        if not pRootOfTree:            return        if not pRootOfTree.left and not pRootOfTree:            return pRootOfTree        node = pRootOfTree        stack = []        res_stack = []        while node or stack:            while node:                stack.append(node)                node = node.left            node = stack.pop()            res_stack.append(node)            node = node.right        result = res_stack[0]        while res_stack:            top = res_stack.pop(0)            if res_stack:                top.right = res_stack[0]                res_stack[0].left = top        return result</code></pre><h1 id="27、字符串的排列"><a href="#27、字符串的排列" class="headerlink" title="27、字符串的排列"></a>27、字符串的排列</h1><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><p>解答：</p><p>方法1：基于回溯法思想</p><p><img src="https://ws2.sinaimg.cn/large/005JV1Cwly1g3cn6cfjedj30zs0ekmyk.jpg" alt="image"></p><p>递归的思想，进行全排列，<a href="http://www.cnblogs.com/cxjchen/p/3932949.html" target="_blank" rel="noopener">解析</a></p><p>方法2：字典序全排列算法，<a href="http://www.cnblogs.com/pmars/archive/2013/12/04/3458289.html" target="_blank" rel="noopener">解析</a></p><p><img src="https://ws1.sinaimg.cn/large/005JV1Cwly1g3cn6ixdn3j30b507fdfx.jpg" alt="image"></p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def __init__(self):        self.result = []    def Permutation(self, ss):        ss = list(ss)        begin = 0        end = len(ss) - 1        self.Permutation_Part(ss, begin, end)        return sorted(self.result)    def Permutation_Part(self, ss, begin, end):        if begin == end:            self.result.append(''.join(ss))            return        for i in range(begin, end + 1):            if self.is_swap(ss, begin, i):                ss[begin], ss[i] = ss[i], ss[begin]                self.Permutation_Part(ss, begin + 1, end)                ss[begin], ss[i] = ss[i], ss[begin]    def is_swap(self, ss, begin, k):        for i in range(begin, k):            if ss[i] == ss[k]:                return False        return Trueclass Solutin():    def Permutation(self, ss):        # write code here        ss = list(ss)        ss_len = len(ss)        if ss_len == 0:            return []        result = []        result.append(''.join(ss))        while True:            i = ss_len - 1            while ss[i - 1] >= ss[i] and i >= 1:                i -= 1            if i == 0:                break            m = i            while m &lt; ss_len and ss[m] > ss[i - 1] :                m += 1            ss[m - 1], ss[i - 1] = ss[i - 1], ss[m - 1]            ss[i:] = sorted(ss[i:])            result.append(''.join(ss))        return result</code></pre><h1 id="28、数组中出现次数超过一半的数字"><a href="#28、数组中出现次数超过一半的数字" class="headerlink" title="28、数组中出现次数超过一半的数字"></a>28、数组中出现次数超过一半的数字</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><p>解答：</p><p>方法1：利用字典存储，在遍历中进行判断value是否大于数组的一半，时间复杂度O(n)，空间复杂度O(n)</p><p>方法2：</p><p>有一个士兵和他自己打架就赢一分，和别人打架就输一分，他的分数是零就出局了。从下一个排号的开始（也可能是他自己）再进行以上，一直比到最后还有分的那个，就可能是胜利者（如果这个胜利者是恰巧赢了那几局，就说明那个出现最多的那个士兵并不存在，所以最后重新计数）时间复杂度O(2*n)，空间复杂度O(1)</p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def MoreThanHalfNum_Solution(self, numbers):    # write code here        number_len = len(numbers)        number_dict = {}        res = []        for i in range(number_len):            if numbers[i] not in number_dict:                number_dict[numbers[i]] = 0            number_dict[numbers[i]] += 1            if number_dict[numbers[i]] > int(number_len / 2):                return numbers[i]        return 0    def MoreThanHalfNum_Solution(self, numbers):        # write code here        if len(numbers) == 0:            return 0        numbers_len = len(numbers)        tag = numbers[0]        count = 1        for i in range(1,numbers_len):            if numbers[i] == tag:                count +=1            else:                count -= 1            if count == 0:                tag = numbers[i]                count = 1        count = 0        for i in numbers:            if i == tag:                count += 1        if count > int(numbers_len / 2):            return tag        return 0</code></pre><h1 id="29、最小的K个数"><a href="#29、最小的K个数" class="headerlink" title="29、最小的K个数"></a>29、最小的K个数</h1><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><p>解答：</p><p>方法：主要考虑的是海量数据下内存不够的情况，使用堆排序，求最小的K个数，则建立K个数的大顶堆，时间复杂度为O(KlogK)，将剩余的元素和堆顶元素比较，小于堆顶元素的进行替换，并刷新大顶堆。最终时间复杂度为O(NlogK)</p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def GetLeastNumbers_Solution(self, tinput, k):        if len(tinput) &lt; k or k == 0:            return []        min_input = tinput[:k]        self.HeapSort(min_input)        for i in tinput[k:]:            if i &lt; min_input[0]:                min_input[0] = i                self.HeapSort(min_input)        return min_input[::-1]    def HeapSort(self,min_input):        k = len(min_input)        i = int(k / 2) - 1        while i >= 0:            self.HeapAdjust(min_input, i, k)            i -= 1        j = k - 1        while j > 0:            min_input[0], min_input[j] = min_input[j], min_input[0]            self.HeapAdjust(min_input, 0, j)            j = j - 1        return min_input    def HeapAdjust(self,min_input,i,n):        j = i * 2 + 1        tag = min_input[i]        while j &lt; n:            if j &lt; n - 1 and min_input[j] > min_input[j+1]:                j = j + 1            if min_input[j] &lt; tag:                min_input[i] = min_input[j]                i = j            else:                break            j = j * 2 + 1        min_input[i] = tag</code></pre><h1 id="30、连续子数组的最大和"><a href="#30、连续子数组的最大和" class="headerlink" title="30、连续子数组的最大和"></a>30、连续子数组的最大和</h1><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><p>解答：</p><p>方法：动态规划</p><p><img src="https://ws3.sinaimg.cn/large/005JV1Cwly1g3cn6qxjuzj30du05cq2x.jpg" alt="image"></p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def FindGreatestSumOfSubArray(self, array):        # write code here        res = array[0]        tmp = array[0]        for i in range(1,len(array)):            tmp = max(tmp + array[i],array[i])            res = max(res,tmp)        return res</code></pre><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;21、栈的压入、弹出序列&quot;&gt;&lt;a href=&quot;#21、栈的压入、弹出序列&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="编程实践" scheme="https://cqupt-wan.github.io/categories/Coding/"/>
    
      <category term="剑指offer" scheme="https://cqupt-wan.github.io/categories/Coding/Sword-to-Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer（11-20）</title>
    <link href="https://cqupt-wan.github.io/20190524-sword-to-offer-2.html"/>
    <id>https://cqupt-wan.github.io/20190524-sword-to-offer-2.html</id>
    <published>2019-05-24T03:08:26.000Z</published>
    <updated>2019-05-24T09:09:24.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11、二进制中1的个数"><a href="#11、二进制中1的个数" class="headerlink" title="11、二进制中1的个数"></a>11、二进制中1的个数</h1><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><p>解答：</p><p>方法：</p><p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p><p>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def NumberOf1(self, n):        # write code here        if n == 0:            return 0        elif n > 0:            tag = 0            while n != 0:                tag += 1                n = n & (n-1)            return tag        else:            n = 2**32 + n            tag = 0            while n != 0:                tag += 1                n = n & (n-1)            return tag</code></pre><h1 id="12、数值的整数次方"><a href="#12、数值的整数次方" class="headerlink" title="12、数值的整数次方"></a>12、数值的整数次方</h1><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>解答：</p><p>方法：快速幂。</p><p><img src="https://wx4.sinaimg.cn/large/005JV1Cwly1g3ci4mve73j309e02o3yc.jpg" alt="image"></p><p>举例:13表示为二进制为1101</p><p>10^1101 = 10^0001<em>10^0100</em>10^1000。</p><p>2^13 = 2^8 <em>2^4 </em>2^1</p><p>2^8 = 2^4 * 2^4</p><p>2^4 = 2^2 * 2^2</p><p>2^2 = 2^1 * 2^1</p><p><img src="https://wx2.sinaimg.cn/large/005JV1Cwly1g3ci5ax9tnj30bl05jt8n.jpg" alt="image"></p><p>右移运算代替除以2；位与运算代替取余，判断奇数和偶数。</p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def Power(self, base, exponent):    # write code here        if abs(base) &lt; 1e-15 and exponent &lt; 0:            return False        elif exponent == 0:            return 1        abs_exponent = abs(exponent)        result = 1.0        tmp_base = base        while abs_exponent != 0:            if (abs_exponent & 1) == 1:                result *= tmp_base            tmp_base *= tmp_base            abs_exponent = abs_exponent >> 1        if exponent > 0:            return result        else:            return 1 / result</code></pre><h1 id="13、调整数组顺序使奇数位于偶数前面"><a href="#13、调整数组顺序使奇数位于偶数前面" class="headerlink" title="13、调整数组顺序使奇数位于偶数前面"></a>13、调整数组顺序使奇数位于偶数前面</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p>解答：</p><p>方法1：以时间换空间，时间复杂度O(n^2)，空间复杂度O(1)。类似冒泡算法，前偶后奇就交换。</p><p>方法2：新建两个列表，时间复杂度O(n)，空间复杂度O(n)</p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def reOrderArray(self, array):        # write code here        n = len(array)        for i in range(n):            j = n - 1            while j > i:                if array[j]&1 == 1 and array[j-1]&1 == 0:                    array[j-1],array[j] = array[j],array[j-1]                j -= 1        return array    def reOrderArray(self, array):    # write code here        n = len(array)        j = 0        for i in range(n):            if (array[j]&1) == 0:                array.append(array[j])                del array[j]            j += 1        return array</code></pre><h1 id="14、链表中倒数第k个结点"><a href="#14、链表中倒数第k个结点" class="headerlink" title="14、链表中倒数第k个结点"></a>14、链表中倒数第k个结点</h1><p>输入一个链表，输出该链表中倒数第k个结点。</p><p>解答：</p><p>方法1：设置两个指针pre和last都指向head，last先向后移动k个位置，然后pre和last一直向后移动至last为空，pre即为倒数第k个结点。</p><p>方法2：将链表的结点append到list中，所求即list的倒数第k位</p><p>注意：count的作用是判断k的值是否大于链表长度，因为链表无法直接计算长度。</p><pre><code class="lang-python"># -*- coding:utf-8 -*-# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def FindKthToTail(self, head, k):        # write code here        if head is None or k &lt; 1:            return None        pre = head        last = head        num = k        count = 0        while last is not None:            last = last.next            count += 1            if num &lt; 1:                pre = pre.next            num -= 1        if count &lt; k:            return None        return pre    def FindKthToTail(self, head, k):    # write code here        if head is None:            return        else:            tmp = []            while head:                tmp.append(head)                head = head.next        if k > len(tmp) or k &lt; 1:            return        return tmp[-k]</code></pre><h1 id="15、反转链表"><a href="#15、反转链表" class="headerlink" title="15、反转链表"></a>15、反转链表</h1><p>输入一个链表，反转链表后，输出新链表的表头。</p><p>解答：</p><p>方法：利用三个指针实现，pre，pHead，nex。</p><p>1、nex保存pHead.next的结点信息，保证后面的链表信息不会消失；</p><p>2、将pre和pHead反转链表，使pHead.next=pre；</p><p>3、最后将pre，pHead，nex全部向后移动一位。</p><p>4、直至pHead为空，则pre为最后一个结点，记录了反转链表的所有信息，即为所求。</p><pre><code class="lang-python"># -*- coding:utf-8 -*-# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    # 返回ListNode    def ReverseList(self, pHead):        # write code here        if not pHead or not pHead.next:            return pHead        pre = None        nex = None        while pHead:            nex = pHead.next            pHead.next = pre            pre = pHead            pHead = nex        return pre</code></pre><h1 id="16、合并两个排序的链表"><a href="#16、合并两个排序的链表" class="headerlink" title="16、合并两个排序的链表"></a>16、合并两个排序的链表</h1><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><p>解答：</p><p>方法1：递归方法，递归中直接pHead = None，pHead = pHead1即可</p><p>方法2：非递归方法，比较pHead1.val和pHead2.val，较小的放入pHead。非递归中创建链表需pHead = ListNode(-1)，pHead.next = None，root = PHead。最后返回链表是root.next，不加.next会将开始的根节点val=-1加进去。注意空链表的情况</p><pre><code class="lang-python"># -*- coding:utf-8 -*-# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    # 返回合并后列表    def Merge(self, pHead1, pHead2):    # write code here        if pHead1 is None:            return pHead2        elif pHead2 is None:            return pHead1        if pHead1.val &lt;= pHead2.val:            pHead = pHead1            pHead.next = self.Merge(pHead1.next, pHead2)        else:            pHead = pHead2            pHead.next = self.Merge(pHead1, pHead2.next)        return pHead    def Merge(self, pHead1, pHead2):        # write code here        if pHead1 is None:            return pHead2        elif pHead2 is None:            return pHead1        pHead = ListNode(None)        root = pHead    #root的作用记录pHead，不能直接返回pHead，因为最后的pHead只指向最后一个元素        while pHead1 and pHead2:            if pHead1.val &lt;= pHead2.val:                pHead.next = pHead1                pHead1 = pHead1.next            else:                pHead.next = pHead2                pHead2 = pHead2.next            pHead = pHead.next        if pHead1:            pHead.next = pHead1        elif pHead2:            pHead.next = pHead2        return root.next</code></pre><h1 id="17、树的子结构"><a href="#17、树的子结构" class="headerlink" title="17、树的子结构"></a>17、树的子结构</h1><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p>解答：</p><p>方法：</p><p><img src="https://ws3.sinaimg.cn/large/005JV1Cwly1g3ci5rrwoyj30fl0kht9f.jpg" alt="image"></p><pre><code class="lang-python"># -*- coding:utf-8 -*-# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def HasSubtree(self, pRoot1, pRoot2):        # write code here        if not pRoot1 or not pRoot2:            return False        return self.is_Subtree(pRoot1,pRoot2) or self.is_Subtree(pRoot1.left,pRoot2) or self.is_Subtree(pRoot1.right,pRoot2)    def is_Subtree(self,A,B):        if not B:            return True        if not A or A.val != B.val:            return False        return self.is_Subtree(A.left,B.left) and self.is_Subtree(A.right,B.right)</code></pre><h1 id="18、二叉树的镜像"><a href="#18、二叉树的镜像" class="headerlink" title="18、二叉树的镜像"></a>18、二叉树的镜像</h1><p>操作给定的二叉树，将其变换为源二叉树的镜像</p><p>解答：</p><p>方法1：递归方法。将根节点的左右子树交换位置，然后分别进行递归镜像函数。因为左右子树包含了其下所有子树的信息。</p><p>方法2：非递归方法。利用栈和队列的思想，在python中利用list实现，首先将根节点append到list中；然后将其pop到一个新建树中，将左右子树交换位置；然后分别将交换位置后得到的左右子树push压入list，即insert(0,p.left)。在while len(st)>0的循环中，st.pop(0)和st.pop()结果相同，由于根节点的左右子树已经交换位置，后面的子树交换顺序无所谓了。</p><pre><code class="lang-python"># -*- coding:utf-8 -*-# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    # 返回镜像树的根节点    def Mirror(self, root):        if not root:            return None        if root:            root.left,root.right = root.right,root.left            self.Mirror(root.left)            self.Mirror(root.right)    def Mirror(self, root):        # write code here        if not root:            return None        st = []        st.append(root)        p = TreeNode(None)        while len(st)>0:            p = st.pop()            p.left,p.right = p.right,p.left            if p.left:                st.append(p.left)            if p.right:                st.append(p.right)</code></pre><h1 id="19、顺时针打印矩阵"><a href="#19、顺时针打印矩阵" class="headerlink" title="19、顺时针打印矩阵"></a>19、顺时针打印矩阵</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><p>解答：</p><p>方法：# 可以模拟魔方逆时针旋转的方法，一直做取出第一行的操作</p><p># 例如</p><p># 1 2 3</p><p># 4 5 6</p><p># 7 8 9</p><p># 输出并删除第一行后，再进行一次逆时针旋转，就变成：</p><p># 6 9</p><p># 5 8</p><p># 4 7</p><p># 继续重复上述操作即可</p><pre><code class="lang-python"># -*- coding:utf-8 -*-# 可以模拟魔方逆时针旋转的方法，一直做取出第一行的操作# 例如 # 1 2 3# 4 5 6# 7 8 9# 输出并删除第一行后，再进行一次逆时针旋转，就变成：# 6 9# 5 8# 4 7# 继续重复上述操作即可。class Solution:    # matrix类型为二维列表，需要返回列表    def printMatrix(self, matrix):    # write code here        result = []        while len(matrix) > 0:            result.extend(matrix[0])            matrix.pop(0)            if matrix:                matrix = self.turn(matrix)        return result    def turn(self, matrix):        r = len(matrix)        c = len(matrix[0])        res = []        for i in range(c)[::-1]:            tmp = []            for j in range(r):                tmp.append(matrix[j][i])            res.append(tmp)        return res</code></pre><h1 id="20、包含min函数的栈"><a href="#20、包含min函数的栈" class="headerlink" title="20、包含min函数的栈"></a>20、包含min函数的栈</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><p>解答：</p><p>方法：利用一个辅助栈来存放最小值。</p><p>栈 3，4，2，5，1</p><p>辅助栈 3，3，2，2，1</p><p>每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶；当出栈时，辅助栈也要出栈；这种做法可以保证辅助栈顶一定都当前栈的最小值</p><pre><code class="lang-python"># -*- coding:utf-8 -*-#思路：利用一个辅助栈来存放最小值#    栈  3，4，2，5，1#    辅助栈 3，3，2，2，1#每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶#当出栈时，辅助栈也要出栈#这种做法可以保证辅助栈顶一定都当前栈的最小值class Solution:    def __init__(self):        self.stack = []        self.min_stack = []    def push(self, node):        # write code here        self.stack.append(node)        if not self.min_stack or self.min_stack[-1] > node:            self.min_stack.append(node)    def pop(self):        # write code here        if self.stack[-1] == self.min_stack[-1]:            self.min_stack.pop()        self.stack.pop()    def top(self):        # write code here        return self.stack[-1]    def min(self):        # write code here        return self.min_stack[-1]</code></pre><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;11、二进制中1的个数&quot;&gt;&lt;a href=&quot;#11、二进制中1的个数&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="编程实践" scheme="https://cqupt-wan.github.io/categories/Coding/"/>
    
      <category term="剑指offer" scheme="https://cqupt-wan.github.io/categories/Coding/Sword-to-Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer（1-10）</title>
    <link href="https://cqupt-wan.github.io/20190523-sword-to-offer-1.html"/>
    <id>https://cqupt-wan.github.io/20190523-sword-to-offer-1.html</id>
    <published>2019-05-23T11:19:24.000Z</published>
    <updated>2019-05-24T12:02:59.775Z</updated>
    
    <content type="html"><![CDATA[<p>牛客网剑指offer编程实践1-10题</p><h1 id="1、二维数组中的查找"><a href="#1、二维数组中的查找" class="headerlink" title="1、二维数组中的查找"></a>1、二维数组中的查找</h1><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数</p><p>解答：</p><p>方法1：遍历整个二维数组，判断数组中是否含有该整数</p><p>方法2：从二维数组的左下角tag开始判断，如果目标整数大于tag，tag右移，如果目标整数小于tag，tag上移。如果相等返回True</p><pre><code class="lang-python">class Solution:    # array 二维列表    def Find(self, target, array):        for i in array:            if target in i:                return True        return False    def Find(self, target, array):        raw = len(array)        col = len(array[0])        i = raw - 1        j = 0        while i >= 0 and j &lt; col:            if array[i][j] &lt; target:                j += 1            elif array[i][j] > target:                i -= 1            else:                return True        return False</code></pre><h1 id="2、替换空格"><a href="#2、替换空格" class="headerlink" title="2、替换空格"></a>2、替换空格</h1><p>请实现一个函数，将一个字符串中的每个空格替换成<code>%20</code>。例如，当字符串为<code>We Are Happy.</code>则经过替换之后的字符串为<code>We%20Are%20Happy</code>。</p><p>解答：</p><p>方法1：将字符串s变换成list，将list中的空格替换成“%20”，然后将list转换成字符串输出。缺点：不是原来的字符串s</p><p>方法2：先遍历以便字符串s，判断有多少个空格，然后从后往前开始替换。</p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    # s 源字符串    def replaceSpace(self, s):        # write code here        s = list(s)        for i in range(len(s)):            if s[i] == ' ':                s[i] = '%20'        return ''.join(s)</code></pre><h1 id="3、从尾到头打印链表"><a href="#3、从尾到头打印链表" class="headerlink" title="3、从尾到头打印链表"></a>3、从尾到头打印链表</h1><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。注意：自定义的listNode函数不能直接使用len()，使用while listNode:</p><p>解答：</p><p>方法1：使用一个栈，遍历链表进行进栈，然后出栈到ArrayList</p><p>方法2：遍历链表到list，然后利用list[::-1]进行输出</p><pre><code class="lang-python"># -*- coding:utf-8 -*-# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    # 返回从尾部到头部的列表值序列，例如[1,2,3]    def printListFromTailToHead(self, listNode):        # write code here        if listNode is None:            return []        tmp = []        while listNode:            tmp.append(listNode.val)            listNode = listNode.next        return tmp[::-1]</code></pre><h1 id="4、重建二叉树"><a href="#4、重建二叉树" class="headerlink" title="4、重建二叉树"></a>4、重建二叉树</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p>解答：</p><p>方法：根据前序遍历第一个元素找到根节点，然后在中序遍历中找到根节点的index，index左边的为根节点的左子树，index右边的为根节点的右子树。然后在两个遍历中截取两个子树进行迭代</p><p>注意：要返回二叉树，而不是数组，</p><pre><code class="lang-python"># -*- coding:utf-8 -*-# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    # 返回构造的TreeNode根节点    def reConstructBinaryTree(self, pre, tin):        # write code here        if len(pre) == 0:            return None        else:            root = TreeNode(pre[0])            tag = tin.index(pre[0])            root.left = self.reConstructBinaryTree(pre[1:tag+1],tin[0:tag])            root.right = self.reConstructBinaryTree(pre[tag+1:],tin[tag+1:])        return root</code></pre><h1 id="5、用两个栈实现队列"><a href="#5、用两个栈实现队列" class="headerlink" title="5、用两个栈实现队列"></a>5、用两个栈实现队列</h1><p>1、用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>解答：</p><p>方法：队列的Push操作就是一个栈A的进栈</p><p>队列的Pop操作，判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；如果不为空，栈B直接出栈。</p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def __init__(self):        self.stack0 = []        self.stack1 = []    def push(self, node):        # write code here        return self.stack0.append(node)    def pop(self):        # return xx        #出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；如果不为空，栈B直接出栈。        if self.stack1 == []:            while self.stack0:                self.stack1.append(self.stack0.pop())        return self.stack1.pop()</code></pre><p>2、用两个队列实现一个栈的功能？要求给出算法和思路！</p><p>方法：</p><p>入栈：将元素进队列A</p><p>出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素以此出队列并放入队列B，直到队列A中的元素留下一个，然后队列A出队列，再把队列B中的元素出队列以此放入队列A中。</p><h1 id="6、旋转数组最小数字"><a href="#6、旋转数组最小数字" class="headerlink" title="6、旋转数组最小数字"></a>6、旋转数组最小数字</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p>解答：</p><p>方法1：遍历整个数组找到最小的元素。</p><p>方法2：因为是非递减数组旋转，利用二分法进行判断，</p><p>如果array[mid] > array[0]，则最小元素在mid的右边。找到的第一个小于array[mid]的元素即最小元素</p><p>如果<code>array[mid] &lt; array[0]</code>，则最小元素在mid的左边。找到的第一个大于array[mid]的元素，它的后一个元素即为最小元素</p><p>注意数组为0，返回0。</p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def minNumberInRotateArray(self, rotateArray):    # write code here        if len(rotateArray) == 0:            return 0        tmp = rotateArray[0]        for i in rotateArray:            if i &lt; tmp:                tmp = i        return tmp    #时间复杂度为O(lgn)，二分法    def minNumberInRotateArray(self, rotateArray):    # write code here        if len(rotateArray) == 0:            return 0        mid = int((len(rotateArray) - 1) / 2)        if rotateArray[mid] >= rotateArray[0]:            for i in rotateArray[mid:]:                if i &lt; rotateArray[mid]:                    return i        else:            for i in reversed(range(mid)):                if rotateArray[i] > rotateArray[mid]:                    return rotateArray[i + 1]</code></pre><h1 id="7、斐波那契数列"><a href="#7、斐波那契数列" class="headerlink" title="7、斐波那契数列"></a>7、斐波那契数列</h1><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<code>n&lt;=39</code></p><p>解答：</p><p>方法：动态规划，一次的结果之和上两个数相关</p><pre><code># -*- coding:utf-8 -*-class Solution:    def Fibonacci(self, n):        # write code here        if n == 0:            return 0        elif n == 1:            return 1        elif n == 2:            return 1        else:            tag = []            tag.append(1)            tag.append(1)            for i in range(2,n):                tag.append(tag[i-1]+tag[i-2])        return tag[n-1]    #从0开始，第0项为0，如果从第一项开始，则为while n > 1:    def Fibonacci(self, n):        f = 0        s = 1        while n:            s = f + s            f = s - f            n -= 1        return f</code></pre><h1 id="8、跳台阶"><a href="#8、跳台阶" class="headerlink" title="8、跳台阶"></a>8、跳台阶</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><p>解答：</p><p>方法：</p><p>a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);</p><p>b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)</p><p>c.由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)</p><p>d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2</p><p>e.可以发现最终得出的是一个斐波那契数列：</p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def jumpFloor(self, number):        # write code here        if number == 1:            return 1        elif number == 2:            return 2        else:            tag = []            tag.append(1)            tag.append(2)            for i in range(2, number):                tag.append(tag[i - 1] + tag[i - 2])        return tag[number-1]    def jumpFloor(self, number):        f = 1        s = 2        while number > 1:            s = f + s            f = s - f            number -= 1        return f</code></pre><h1 id="9、变态跳台阶"><a href="#9、变态跳台阶" class="headerlink" title="9、变态跳台阶"></a>9、变态跳台阶</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>解答：</p><p>方法1：f(1) = 1</p><p>f(2) = f(2-1) + f(2-2) f(2-2)表示一次跳2级台阶</p><p>f(3) = f(3-1) + f(3-2) +f(3-3)</p><p>f(n) = f(n-1) +…+ f(n-(n-1)) + f(n-n)</p><p>​ = f(0) + f(1) +…+f(n-1)</p><p>f(n-1) = f(0) + f(1) +…+f(n-2)</p><p>f(n) = 2*f(n-1)</p><p>方法2：<strong>每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)中情况</strong></p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def jumpFloorII(self, number):        # write code here        return 2**(number-1)    def jumpFloorII(self, number):        if number &lt;= 0:            return -1        elif number == 1:            return 1        return 2*self.jumpFloorII(number-1)</code></pre><h1 id="10、矩阵覆盖"><a href="#10、矩阵覆盖" class="headerlink" title="10、矩阵覆盖"></a>10、矩阵覆盖</h1><p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？</p><p>解答:</p><p>方法：同上面的斐波那契数列，只是f(1) = 1,f(2) = 2</p><pre><code class="lang-python"># -*- coding:utf-8 -*-class Solution:    def rectCover(self, number):        # write code here            if number == 0:                return 0            if number == 1:                return 1            elif number == 2:                return 2            else:                tag = []                tag.append(1)                tag.append(2)                for i in range(2, number):                    tag.append(tag[i - 1] + tag[i - 2])            return tag[-1]    def rectCover(self, number):        if number == 0:            return 0        elif number == 1:            return 1        elif number == 2:            return 2        f = 1        s = 2        while number > 1:            s = s + f            f = s - f            number -= 1        return f</code></pre><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;牛客网剑指offer编程实践1-10题&lt;/p&gt;&lt;h1 id=&quot;1、二维数组中的查找&quot;&gt;&lt;a href=&quot;#1、二维数组中的查找&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="编程实践" scheme="https://cqupt-wan.github.io/categories/Coding/"/>
    
      <category term="剑指offer" scheme="https://cqupt-wan.github.io/categories/Coding/Sword-to-Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo搭建git博客</title>
    <link href="https://cqupt-wan.github.io/20190520-hexo-blog-optimization.html"/>
    <id>https://cqupt-wan.github.io/20190520-hexo-blog-optimization.html</id>
    <published>2019-05-20T01:41:08.000Z</published>
    <updated>2019-05-23T01:25:36.007Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要内容是本站博客使用Next主题的个性化定制和部分优化细节。最后<a href="https://cqupt-wan.github.io/">搭建的博客</a>。</p><h1 id="开始-Hexo-github搭建个人博客"><a href="#开始-Hexo-github搭建个人博客" class="headerlink" title="开始 Hexo+github搭建个人博客"></a>开始 Hexo+github搭建个人博客</h1><ul><li>Hexo博客搭建的基础流程为：<br>安装Node.js→安装Git→安装主题→注册给github并创建pages仓库→部署</li></ul><p>首先可以将Hexo<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a>看一遍，然后可以参考这篇文章<a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">使用Hexo+Github一步步搭建属于自己的博客（基础）</a>进行配置。如果想将博客同步到coding上可以查看这篇文章：<a href="https://yangbingdong.com/2017/build-blog-hexo-base/#GitHub" target="_blank" rel="noopener">基于Hexo+Github+Coding搭建个人博客——基础篇(从菜鸟到放弃)</a>。之后在站点文件夹根目录，安装Git部署插件（以后所有安装的插件都在这个目录），输入下面命令：</p><pre><code class="lang-powershell">所在目录：~/Blog/npm install hexo-deployer-git --save</code></pre><p>然后在站点根目录下配置文件，编辑：</p><pre><code class="lang-powershell">文件位置：~/Blog/_config.ymlurl: https://cqupt-wan.github.io/..省略....# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repository: git@github.com:CQUPT-Wan/CQUPT-Wan.github.io.git  branch: master  # other deployer  -type: leancloud_counter_security_sync</code></pre><p>将其中的cqupt-wan更改为你的git账号即可，可以执行<code>hexo s</code>在 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 本地调试成功后，执行 <code>hexo clean && hexo g && hexo d</code> 上传到git博客上。</p><h2 id="站点根目录内容"><a href="#站点根目录内容" class="headerlink" title="站点根目录内容"></a>站点根目录内容</h2><p>建立好的站点根目录如下：</p><pre><code class="lang-yaml">.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><p>每个文件或文件夹的功能如下：</p><ol><li><strong>_config.yml</strong></li></ol><p>站点博客的配置文件，博客的名称、关键词、作者、语言、博客主题…设置都在里面。</p><ol><li><strong>package.json</strong></li></ol><p>应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。</p><ol><li><strong>scaffolds</strong></li></ol><p>scaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容</p><ol><li><strong>source</strong></li></ol><p>source是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。</p><ol><li><strong>themes</strong></li></ol><p>放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。</p><h1 id="优化-基本功能配置"><a href="#优化-基本功能配置" class="headerlink" title="优化 基本功能配置"></a>优化 基本功能配置</h1><h2 id="更换博客主题"><a href="#更换博客主题" class="headerlink" title="更换博客主题"></a>更换博客主题</h2><p>两个Hexo主题下载的地方：</p><p>知乎话题：<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">有哪些好看的 Hexo 主题？</a></p><p>Hexo官方：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Themes</a></p><p>然后使用clone的方式将主题下载，本站博客选用的是Hexo的next主题</p><pre><code class="lang-powershell">所在目录：~/Blog/git clone https://github.com/theme-next/hexo-theme-next themes/next</code></pre><p>clone完成后，修改配置文件中的theme选项</p><pre><code class="lang-powershell">文件位置：~/Blog/_config.yml## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next</code></pre><p>此外，可以在主题配置文件中修改next主题的不同风格，本站使用的是Mist风格</p><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/_config.yml# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#cheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini</code></pre><h2 id="设置Menu"><a href="#设置Menu" class="headerlink" title="设置Menu"></a>设置Menu</h2><p>默认只有首页和归档两个，如果还需要添加其他，需要修改主题配置文件：</p><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/_config.ymlmenu:  home: / || home  //首页  about: /about/ || user  //关于  tags: /tags/ || tags  //标签  categories: /categories/ || th  //分类  archives: /archives/ || archive  //归档  #schedule: /schedule/ || calendar  //日程表  #sitemap: /sitemap.xml || sitemap  //站点地图  #commonweal: /404/ || heartbeat  //公益404</code></pre><p>修改完配置文件后，还需要创建对应的文件夹，以tags标签为例</p><pre><code class="lang-powershell">所在目录：~/Blog/hexo new page "tags"</code></pre><p>此外，还需要修改对应文件夹中的index.md文件，comment对应后面的评论系统</p><pre><code class="lang-powershell">文件位置：~/Blog/source/tags/index.md---title: 所有标签date: 2019-05-16 15:12:51type: "tags"comments: false---</code></pre><h2 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h2><p>修改主题配置文件，将enable改为true即可</p><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/_config.yml# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest:  enable: true  onmobile: true # display on mobile or not  color: "0,0,255" # RGB values, use ',' to separate  opacity: 0.5 # the opacity of line: 0~1  zIndex: -1 # z-index property of the background  count: 99 # the number of lines</code></pre><p>配置项说明：</p><ul><li><code>color</code> ：线条颜色, 默认: <code>'0,0,255'</code>；三个数字分别为(R,G,B)</li><li><code>opacity</code>： 线条透明度（0~1）, 默认: <code>0.5</code></li><li><code>count</code>：线条的总数量, 默认: <code>99</code></li><li><code>zIndex</code> ：背景的z-index属性，css属性用于控制所在层的位置, 默认: <code>-1</code></li></ul><h2 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h2><p>首先安装Hexo插件</p><pre><code class="lang-powershell">所在目录：~/Blog/ npm install --save hexo-generator-feed</code></pre><p>编辑站点配置文件</p><pre><code class="lang-powershell">文件位置：~/Blog/_config.yml## Plugins: https://hexo.io/plugins/plugins: hexo-generate-feed</code></pre><p>配置主题文件</p><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/_config.yml# Set rss to false to disable feed link.# Leave rss as blank to use site's feed link, and install hexo-generator-feed: `npm install hexo-generator-feed --save`.# Set rss to specific value if you have burned your feed already.rss: /atom.xml</code></pre><h2 id="修改链接样式"><a href="#修改链接样式" class="headerlink" title="修改链接样式"></a>修改链接样式</h2><pre><code class="lang-powershell">文件位置：~Blog/themes/next/source/css/_common/components/post/post.styl// 文章内链接文本样式.post-body p a {  color: #0593d3;  //原始链接颜色  border-bottom: none;  border-bottom: 1px solid #0593d3;  //底部分割线颜色  &:hover {    color: #fc6423;  //鼠标经过颜色    border-bottom: none;    border-bottom: 1px solid #fc6423;  //底部分割线颜色  }}</code></pre><h2 id="修改底部标签样式"><a href="#修改底部标签样式" class="headerlink" title="修改底部标签样式"></a>修改底部标签样式</h2><p>原本的标签是‘#’，感觉很丑，所有将<code>rel="tag">#</code>标签更改为<code>rel="tag">&lt;i class="fa fa-tag"&gt;</code>现在这个样子</p><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/layout/_macro/post.swig<xmp><div class="post-tags">          {% for tag in post.tags %}            <a href="{{ url_for(tag.path) }}" rel="tag"><i class="fa fa-tag"></i> {{ tag.name }}</a>          {% endfor %}        </div>        <i class="fa fa-tag"></xmp></code></pre><h2 id="在文章末尾添加“文章结束”标志"><a href="#在文章末尾添加“文章结束”标志" class="headerlink" title="在文章末尾添加“文章结束”标志"></a>在文章末尾添加“文章结束”标志</h2><p>首先新建<code>passage-end-tag.swig</code>文件</p><pre><code class="lang-powershell">所在目录：~/Blog/themes/next/layout/_macro//创建passage-end-tag.swig文件touch passage-end-tag.swig</code></pre><p>编辑该文件</p><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/layout/_macro/passage-end-tag.swig<xmp><div>    {% if not is_index %}        <div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束啦<i class="fa fa-thumbs-up" aria-hidden="true"></i>感谢您的阅读-------------</div>    {% endif %}</div>;</xmp></code></pre><p>然后修改<code>post.swig</code>配置文件，在<code>END POST BODY</code>之后添加</p><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/layout/_macro\post.swig<xmp>{% if not is_index %}    <div>    {% include '../_macro/passage-end-tag.swig' %}    </div>    {% endif %}</xmp></code></pre><p>最后修改主题配置文件即可</p><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/_config.yml# 文章末尾添加“本文结束”标记passage_end_tag:  enabled: true</code></pre><h2 id="设置网站图标Favicon"><a href="#设置网站图标Favicon" class="headerlink" title="设置网站图标Favicon"></a>设置网站图标Favicon</h2><p>不论是网站的图标还是头像都存储在<code>~/Blog/themes/next/source/images</code>中，只需要将默认的图片替换掉即可</p><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/_config.ymlfavicon:  small: /images/pikapika-16-16.png  medium: /images/pikapika-32-32.png  apple_touch_icon: /images/pikapika.png  safari_pinned_tab: /images/pikapika.svg  #android_manifest: /images/manifest.json  #ms_browserconfig: /images/browserconfig.xml</code></pre><p><a href="http://www.bejson.com/convert/image_to_svg/" target="_blank" rel="noopener">图片转svg在线生成器</a></p><h1 id="进阶-高级功能配置"><a href="#进阶-高级功能配置" class="headerlink" title="进阶 高级功能配置"></a>进阶 高级功能配置</h1><h2 id="添加热度"><a href="#添加热度" class="headerlink" title="添加热度"></a>添加热度</h2><p>进入<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleancloud.cn%2F" target="_blank" rel="noopener">LeanCloud官网</a>，进行账号注册。登录后，进入控制台，创建应用，应用名为<code>Hexo</code>如下图所示：</p><p><img src="https://wx1.sinaimg.cn/large/005JV1Cwly1g3967rs6kwj30rs0fb0vo.jpg" alt="image"></p><p>创建应用后，点击存储，创建<strong>Class</strong>，<strong>Class</strong>命名为<strong>Counter</strong>，操作如下图所示：</p><p><img src="https://ws4.sinaimg.cn/large/005JV1Cwly1g3964gch27j30ie07y0u3.jpg" alt="image"></p><p><img src="https://wx2.sinaimg.cn/large/005JV1Cwly1g3968wb8w3j30rs0klwku.jpg" alt="image"></p><p>查看<strong>AppID</strong>和<strong>AppKey</strong>，如下图所示：</p><p><img src="https://wx2.sinaimg.cn/large/005JV1Cwly1g39699n2baj30n407sq2u.jpg" alt="image"></p><p>加入热度符号：</p><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/layout/_macro\post.swig<xmp>          {% if theme.leancloud_visitors.enable or (theme.valine.enable and theme.valine.appid and theme.valine.appkey and theme.valine.visitor) %}            <span id="{{ url_for(post.path) }}" class="leancloud_visitors" data-flag-title="{{ post.title }}">              <span class="post-meta-divider">|</span>              <span class="post-meta-item-icon">                <i class="fa fa-eye"></i>              </span>              {% if theme.post_meta.item_text %}                <span class="post-meta-item-text">{{ __('post.views') + __('symbol.colon') }}</span>              {% endif %}                <span class="leancloud-visitors-count"></span>                  <span>&#x2103;</span>            </span>          {% endif %}</xmp></span></code></pre><h2 id="添加来必力云跟帖功能"><a href="#添加来必力云跟帖功能" class="headerlink" title="添加来必力云跟帖功能"></a>添加来必力云跟帖功能</h2><p>首先去<a href="https://links.jianshu.com/go?to=https%3A%2F%2Flivere.com%2F" target="_blank" rel="noopener">来必力</a>注册账号，然后进入后台管理系统，如下图所示：</p><p><img src="https://wx2.sinaimg.cn/large/005JV1Cwly1g398j5wu1mj30f00c20tn.jpg" alt="image"></p><p>拷贝下图中的<code>data-uid</code></p><p><img src="https://ws1.sinaimg.cn/large/005JV1Cwly1g398ltds1uj30q50i60tj.jpg" alt="image"></p><p>编辑主题配置文件，将上面的<code>data-uid</code>粘贴到下面位置</p><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/_config.yml# LiveRe comments system# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid:</code></pre><p>当分类、标签、关于等组件需要隐藏评论功能时</p><ul><li>编辑<strong>index.md</strong>文件，添加<strong>comments</strong>将其值设为<strong>false</strong>:</li></ul><pre><code class="lang-powershell">文件位置：~/Blog/source/abouttitle: About Medate: 2019-05-16 16:04:06type: "about"comments: false</code></pre><h2 id="配置网站底部内容"><a href="#配置网站底部内容" class="headerlink" title="配置网站底部内容"></a>配置网站底部内容</h2><h3 id="底部隐藏Hexo强力驱动"><a href="#底部隐藏Hexo强力驱动" class="headerlink" title="底部隐藏Hexo强力驱动"></a>底部隐藏Hexo强力驱动</h3><ol><li>设置主题配置文件</li></ol><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/_config.ymlfooter:  # Specify the date when the site was setup. If not defined, current year will be used.  since: 2019</code></pre><ol><li>修改中文内容</li></ol><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/languages/zh-CN.ymlfooter:  powered: "由 %s 个人专属"  theme: 主题  total_views: 总访问量  total_visitors: 总访客量</code></pre><ol><li>打开<code>Blog/themes/next/layout/_partials/footer.swig</code>，修改相应代码。</li></ol><pre><code>文件位置：~/Blog/themes/next/layout/_partials/footer.swig{% if theme.footer.powered.enable %}  <div class="powered-by">{#  #}{{ __('footer.powered', next_url('https://github.com/CQUPT-Wan', 'CQUPT-Wan', {class: 'theme-link'})) }}{#  #}{% if theme.footer.powered.version %} v{{ hexo_env('version') }}{% endif %}</div>{% endif %}</div></code></pre><h3 id="网站底部字数统计"><a href="#网站底部字数统计" class="headerlink" title="网站底部字数统计"></a>网站底部字数统计</h3><p>安装hexo插件，切换到根目录：</p><pre><code class="lang-powershell">根目录：~/Blognpm install hexo-wordcount --save</code></pre><p>在<code>~/Blog/themes/next/layout/_partials/footer.swig</code>添加代码：注意这段代码添加的位置和底部最后显示的位置相关，我是加在<code>author</code>后面</p><pre><code class="lang-powershell"> 文件位置：~/Blog/themes/next/layout/_partials/footer.swig <xmp> <span class="author" itemprop="copyrightHolder">{{ theme.footer.copyright || author }}</span>  <span class="post-meta-divider">|</span>  <div class="theme-info">      <div class="powered-by"></div>      <span class="post-count">博客全站共{{ totalcount(site) }}字</span>    </div></xmp></code></pre><h3 id="让页脚的心跳动起来"><a href="#让页脚的心跳动起来" class="headerlink" title="让页脚的心跳动起来"></a>让页脚的心跳动起来</h3><p>首先编辑主题配置文件</p><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/_config.ymlicon:     # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/    # `heart` is recommended with animation in red (#ff0000).    name: heart</code></pre><p>然后编辑</p><pre><code> 文件位置：~/Blog/themes/next/layout/_partials/footer.swig<span class="with-love" id="heart"></code></pre><p>最后编辑<code>custom.styl</code>，加入：</p><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/source/css/_custom/custom.styl// 自定义页脚跳动的心样式@keyframes heartAnimate {    0%,100%{transform:scale(1);}    10%,30%{transform:scale(0.9);}    20%,40%,60%,80%{transform:scale(1.1);}    50%,70%{transform:scale(1.1);}}#heart {    animation: heartAnimate 1.33s ease-in-out infinite;}.with-love {    color: rgb(255, 0, 0);}</code></pre><h2 id="添加DaoVoice在线联系"><a href="#添加DaoVoice在线联系" class="headerlink" title="添加DaoVoice在线联系"></a>添加DaoVoice在线联系</h2><ol><li>首先到<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.daocloud.io%2F" target="_blank" rel="noopener">DaoVoice</a>注册账号，登录成过后，进入到后台管理，点击<strong>应用设置——>安装到网站</strong>查看安装代码和AppID。</li><li>将安装代码添加到<code>Blog/themes/next/layout/_partials/head.swig</code>中：</li></ol><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/layout/_partials/head.swig{% if theme.daovoice %}  <script>!function(e,t,o,i,a,c,n){e.DaoVoiceObject=a,e[a]=e[a]||function(){(e[a].q=e[a].q||[]).push(arguments)},e[a].l=1*new Date,c=t.createElement(o),n=t.getElementsByTagName(o)[0],c.async=1,c.src=i,c.charset="utf-8",n.parentNode.insertBefore(c,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"{{theme.daovoice_app_id}}"}),daovoice("update")</script>{% endif %}</code></pre><ol><li>配置主题文件</li></ol><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/_config.yml# Online contact daovoice: truedaovoice_app_id: ab02c609</code></pre><h2 id="Hexo博客添加站内搜索"><a href="#Hexo博客添加站内搜索" class="headerlink" title="Hexo博客添加站内搜索"></a>Hexo博客添加站内搜索</h2><ol><li><p>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。</p></li><li><p>安装 hexo-generator-search</p></li></ol><pre><code class="lang-powershell">目录：~/Blognpm install hexo-generator-search --save</code></pre><ol><li>安装 hexo-generator-searchdb</li></ol><pre><code class="lang-powershell">目录：~/Blognpm install hexo-generator-searchdb --save</code></pre><ol><li>编辑站点配置文件</li></ol><pre><code class="lang-powershell">文件位置：~/Blog/_config.yml# 搜索search:  path: search.xml  field: post  format: html  limit: 10000</code></pre><ol><li>编辑主题配置文件，设置<code>Local search</code>enable为<code>ture</code></li></ol><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/_config.yml# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search:  enable: true  # If auto, trigger search by changing input.  # If manual, trigger search by pressing enter key or search button.  trigger: auto  # Show top n results per article, show all results by setting to -1  top_n_per_article: 1  # Unescape html strings to the readable one.  unescape: false</code></pre><h2 id="文章底部添加版权声明"><a href="#文章底部添加版权声明" class="headerlink" title="文章底部添加版权声明"></a>文章底部添加版权声明</h2><ol><li>在目录 <code>~/Blog/themes/next/layout/_macro/</code> 下添加 <code>my-copyright.swig</code> ，内容如下：</li></ol><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/layout/_macro/my-copyright.swig<xmp>{% if page.copyright %}<div class="my_post_copyright">  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>      <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>  <p><span>本文标题:</span><a href="{{ url_for(page.path) }}">{{ page.title }}</a></p>  <p><span>文章作者:</span><a href="/" title="访问 {{ theme.author }} 的个人博客">{{ theme.author }}</a></p>  <p><span>发布时间:</span>{{ page.date.format("YYYY年MM月DD日 - HH:MM") }}</p>  <p><span>最后更新:</span>{{ page.updated.format("YYYY年MM月DD日 - HH:MM") }}</p>  <p><span>原始链接:</span><a href="{{ url_for(page.path) }}" title="{{ page.title }}">{{ page.permalink }}</a>    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="{{ page.permalink }}" aria-label="复制成功！"></i></span>  </p>  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  </div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script>{% endif %}</xmp></code></pre><ol><li>在目录<code>~/Blog/themes/next/source/css/_common/components/post/</code>下添加文件<code>my-post-copyright.styl</code>，添加以下代码：</li></ol><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/source/css/_common/components/post/my-post-copyright.styl.my_post_copyright {  width: 85%;  max-width: 45em;  margin: 2.8em auto 0;  padding: 0.5em 1.0em;  border: 1px solid #d3d3d3;  font-size: 0.93rem;  line-height: 1.6em;  word-break: break-all;  background: rgba(255,255,255,0.4);}.my_post_copyright p{margin:0;}.my_post_copyright span {  display: inline-block;  width: 5.2em;  color: #b5b5b5;  font-weight: bold;}.my_post_copyright .raw {  margin-left: 1em;  width: 5em;}.my_post_copyright a {  color: #808080;  border-bottom:0;}.my_post_copyright a:hover {  color: #a3d2a3;  text-decoration: underline;}.my_post_copyright:hover .fa-clipboard {  color: #000;}.my_post_copyright .post-url:hover {  font-weight: normal;}.my_post_copyright .copy-path {  margin-left: 1em;  width: 1em;  +mobile(){display:none;}}.my_post_copyright .copy-path:hover {  color: #808080;  cursor: pointer;}</code></pre><ol><li>修改<code>~/Blog/themes/next/layout/_macro/post.swig</code>，在<code>END POST BODY</code>后面添加以下代码：</li></ol><pre><code class="lang-html">文件位置：~/Blog/themes/next/layout/_macro/post.swig<xmp><div>      {% if not is_index %}        {% include 'my-copyright.swig' %}      {% endif %}    </div></xmp></code></pre><ol><li>在<code>~/Blog/themes/next/source/css/_common/components/post/post.styl</code>文件最后加入下面的代码：<code>@import "my-post-copyright"</code></li></ol><h2 id="修改网站url"><a href="#修改网站url" class="headerlink" title="修改网站url"></a>修改网站url</h2><p>因为写的博客存在中文标题，如果直接用默认的<code>url</code>会出现中文，这样容易出现网址Bug。修改方式如下</p><pre><code class="lang-powershell">文件位置：~/Blog/_config.yml#permalink: :year/:month/:day/:title/permalink: :year:month:day-:url_name.htmlpermalink_defaults:    url_name: index</code></pre><p>这里的<code>url_name</code>需要在每篇新建博客的<code>.md</code>文件中设置你想设置的网址名，如果嫌麻烦可以修改模板</p><pre><code>文件位置：~/Blog/scaffolds/post.md---title: {{ title }}url_name: date: {{ date }}tags:categories:copyright:---</code></pre><p>对于标签中的中文，可以编辑站点配置文件进行设定：</p><pre><code class="lang-powershell">文件位置：~/Blog/_config.yml# Category & Tagdefault_category: uncategorized# URL 中的分类和标签「翻译」成英文category_map:        机器学习: MachineLearning        自然语言处理: NLP        深度学习: DeepLearning        数据结构: DataStructure        编程实践: Codingtag_map:</code></pre><h2 id="侧栏加入已运行时间"><a href="#侧栏加入已运行时间" class="headerlink" title="侧栏加入已运行时间"></a>侧栏加入已运行时间</h2><p>首先加入下面代码</p><pre><code class="lang-html">文件位置：~/Blog/themes/next/layout/_custom/sidebar.swig<xmp><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()", 1000);BirthDay=new Date("05/15/2019 15:13:14");today=new Date();timeold=(today.getTime()-BirthDay.getTime());sectimeold=timeold/1000secondsold=Math.floor(sectimeold);msPerDay=24*60*60*1000e_daysold=timeold/msPerDaydaysold=Math.floor(e_daysold);e_hrsold=(e_daysold-daysold)*24;hrsold=setzero(Math.floor(e_hrsold));e_minsold=(e_hrsold-hrsold)*60;minsold=setzero(Math.floor((e_hrsold-hrsold)*60));seconds=setzero(Math.floor((e_minsold-minsold)*60));document.getElementById('days').innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒";}function setzero(i){if (i<10){i="0" + i};return i;}show_date_time();</script></xmp></code></pre><p>上面<code>Date</code>需要修改为你自己的，然后修改文件：</p><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/layout/_macro/sidebar.swig\<xmp>            <ul class="links-of-blogroll-list">              {% for name, link in theme.links %}                <li class="links-of-blogroll-item">                  <a href="{{ link }}" title="{{ name }}" target="_blank">{{ name }}</a>                </li>              {% endfor %}            </ul>+        {% include '../_custom/sidebar.swig' %}          </div>         {% endif %}-        {% include '../_custom/sidebar.swig' %}</xmp></code></pre><p>如果需要修改颜色，则可以修改<code>custom.styl</code></p><pre><code>// 自定义的侧栏时间样式#days {    display: block;    color: #f56e25;    font-size: 10px;    margin-top: 10px;}    .site-overview {    text-align: center;}</code></pre><h2 id="设置页面内容居中"><a href="#设置页面内容居中" class="headerlink" title="设置页面内容居中"></a>设置页面内容居中</h2><p>本博客使用的主题是Next.Mist，首页内容默认为</p><p><img src="https://ws1.sinaimg.cn/large/005JV1Cwly1g3az83fntuj30ov09ft92.jpg" alt="image"></p><p>如果想修改标题的位置居中或者‘阅读全文’居中，首先可以<code>F12</code>审查元素查看要修改内容的class，然后进行修改</p><pre><code class="lang-powershell">文件位置：~/Blog/themes/next/source/css/_schemes/Mist/_posts-expanded.styl// Post Expanded// --------------------------------------------------.posts-expand {  padding-top: 0;  .post-title,  .post-meta {    text-align: center $site-meta-text-align;  //文章属性位置    +mobile() { text-align: center; }  }  .post-eof { display: none; }  .post { margin-top: 120px; }  .post:first-child { margin-top: 0; }  .post-meta {    margin-top: 5px;    margin-bottom: 20px;  }  .post-title {    position: center;  //文章标题位置    font-size: $font-size-headings-base;    font-weight: 400;    +mobile() { font-size: $font-size-headings-small; }    +desktop-large() { font-size: $font-size-headings-large; }  }  .post-title:hover:before { background: $black-deep; }  .post-body {    +mobile() { font-size: $font-size-base; }  }  .post-body img { margin: 0; }  .post-tags {    text-align: left;    a {      padding: 1px 5px;      background: $whitesmoke;      border-bottom: none;    }    a:hover { background: $grey-light; }  }  .post-nav { margin-top: 40px; }}.post-button {  margin-top: 20px;  text-align: right;  //阅读全文位置  a {    padding: 0;    font-size: $font-size-base;    //color: $grey-dim;    background: none;    border: none;    border-bottom: 2px solid $grey-dim;    transition-property: border;    +mobile() { font-size: $font-size-small; }    +desktop-large() { font-size: $font-size-large; }    &:hover { border-bottom-color: $black-deep; }  }}</code></pre><p>如果要修改其他主题的内容位置，将<code>~/Blog/themes/next/source/css/_schemes/Mist/_posts-expanded.styl</code>中的<code>Mist</code>修改即可。</p><h2 id="参考大佬的文章"><a href="#参考大佬的文章" class="headerlink" title="参考大佬的文章"></a>参考大佬的文章</h2><blockquote><table><tbody><tr><td bgcolor="LemonChiffon"><font size="3">tips：大佬的博客可不仅仅有一篇文章，多在上面逗留会，也许会有甜品。</font></td></tr></tbody></table></blockquote><ol><li><p><a href="https://io-oi.me/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#fn:2" target="_blank" rel="noopener">打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a></p></li><li><p><a href="http://shenzekun.cn/hexo的next主题个性化配置教程.html" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></p></li><li><p><a href="https://www.jianshu.com/p/9f0e90cc32c2" target="_blank" rel="noopener">Hext-Next配置超炫网页效果</a></p></li></ol><blockquote><table><tbody><tr><td bgcolor="LemonChiffon"><font size="4.5">最后如果转载，麻烦留个本文的链接，因为如果读者或我自己发现文章有错误，我会在这里更正，留个本文的链接，防止我暂时的疏漏耽误了他人宝贵的时间。</font></td></tr></tbody></table></blockquote><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;本文主要内容是本站博客使用Next主题的个性化定制和部分优化细节。最后&lt;a href=&quot;https://cqupt-wan.github.io/&quot;&gt;搭建的博客&lt;/a&gt;。&lt;/p&gt;&lt;h1 id=&quot;开始-Hexo-github搭建个人博客&quot;&gt;&lt;a
        
      
    
    </summary>
    
      <category term="hexo" scheme="https://cqupt-wan.github.io/categories/hexo/"/>
    
    
      <category term="Hexo" scheme="https://cqupt-wan.github.io/tags/Hexo/"/>
    
      <category term="git" scheme="https://cqupt-wan.github.io/tags/git/"/>
    
  </entry>
  
</feed>
